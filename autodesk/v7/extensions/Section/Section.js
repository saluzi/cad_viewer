/*!
 * LMV v7.1.0
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Section =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Section/Section.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Section/Section.css":
/*!****************************************!*\
  !*** ./extensions/Section/Section.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Section.css */ "./node_modules/css-loader/index.js!./extensions/Section/Section.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Section/Section.js":
/*!***************************************!*\
  !*** ./extensions/Section/Section.js ***!
  \***************************************/
/*! exports provided: SectionExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectionExtension", function() { return SectionExtension; });
/* harmony import */ var _SectionTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SectionTool */ "./extensions/Section/SectionTool.js");
/* harmony import */ var _Section_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Section.css */ "./extensions/Section/Section.css");
/* harmony import */ var _Section_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Section_css__WEBPACK_IMPORTED_MODULE_1__);



/**
                                  * The SectionExtension provides ways to cut the geometry using planes or a cube.
                                  * The extension adds a toolbar button to access the feature. 
                                  * 
                                  * The extension id is: `Autodesk.Section`
                                  * 
                                  * @example
                                  *   viewer.loadExtension('Autodesk.Section')
                                  * 
                                  * @memberof Autodesk.Viewing.Extensions
                                  * @alias Autodesk.Viewing.Extensions.SectionExtension
                                  * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
                                  * @constructor
                                  */
var SectionExtension = function SectionExtension(viewer, options) {
  Autodesk.Viewing.Extension.call(this, viewer, options);
  this.viewer = viewer;
  this.name = 'section';
  this.modes = ['x', 'y', 'z', 'box'];

  this.onViewerSetView = this.onViewerSetView.bind(this);
  this.onCutPlanesChangedBinded = this.onCutPlanesChanged.bind(this);
};

SectionExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
SectionExtension.prototype.constructor = SectionExtension;

var proto = SectionExtension.prototype;

/**
                                         * Registers the SectionTool, hotkeys and event handlers.
                                         *
                                         * @returns {boolean}
                                         */
proto.load = function () {
  var that = this;
  var viewer = this.viewer;

  this.tool = new _SectionTool__WEBPACK_IMPORTED_MODULE_0__["SectionTool"](viewer, {
    tintColor: { r: 1, g: 1, b: 0 },
    tintIntensity: 0.2 });

  viewer.toolController.registerTool(this.tool);
  this.sectionStyle = null;
  this.supportedStyles = ["X", "Y", "Z", "BOX"];

  viewer.addEventListener(Autodesk.Viewing.SET_VIEW_EVENT, this.onViewerSetView);

  // consider cutplane changes of other tools, so that cap meshes consider them too
  viewer.addEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onCutPlanesChangedBinded);

  this.HOTKEYS_ID = "Autodesk.Section.Hotkeys";
  var hotkeys = [{
    keycodes: [
    Autodesk.Viewing.KeyCode.ESCAPE],

    onRelease: function onRelease() {
      return that.deactivate();
    } }];

  viewer.getHotkeyManager().pushHotkeys(this.HOTKEYS_ID, hotkeys);

  //Load the required dependency (and return the pending load as the load completion Promise)
  return this.viewer.loadExtension('Autodesk.CompGeom');
};

/**
    * Unregisters the SectionTool, hotkeys and event handlers.
    *
    * @returns {boolean}
    */
proto.unload = function () {
  var viewer = this.viewer;

  // remove hotkey
  viewer.getHotkeyManager().popHotkeys(this.HOTKEYS_ID);

  this.destroyUI();

  viewer.removeEventListener(Autodesk.Viewing.SET_VIEW_EVENT, this.onViewerSetView);
  viewer.removeEventListener(Autodesk.Viewing.CUTPLANES_CHANGE_EVENT, this.onCutPlanesChangedBinded);

  viewer.toolController.deregisterTool(this.tool);
  this.tool = null;

  return true;
};

/**
    * Toggles activeness of section planes.
    * @returns {boolean} Whether the section plane is active or not.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#toggle
    */
proto.toggle = function () {
  if (this.isActive()) {
    this.enableSectionTool(false);
  } else {
    var style = this.sectionStyle || "X";
    this.setSectionStyle(style, true);
  }
  return this.isActive(); // Need to check for isActive() again.
};

/**
    * Returns the current type of plane that will cut-though the geometry.
    *
    * @returns {null|String} Either "X" or "Y" or "Z" or "BOX" or null.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#getSectionStyle
    */
proto.getSectionStyle = function () {
  return this.sectionStyle;
};

/**
    * Sets the Section plane style.
    *
    * @param {String} style - Accepted values are 'X', 'Y', 'Z' and 'BOX' (in Caps)
    * @param {Boolean} [preserveSection] - Whether sending the current style value resets the cut planes.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionStyle
    */
proto.setSectionStyle = function (style, preserveSection) {

  if (this.supportedStyles.indexOf(style) === -1) {
    return false;
  }

  var bActive = this.isActive();
  var bNewStyle = this.sectionStyle !== style || !preserveSection;
  this.sectionStyle = style;

  if (bActive && bNewStyle) {
    this.tool.setSection(style);
  } else
  if (!bActive) {
    this.enableSectionTool(true);
    if (bNewStyle) {
      this.tool.setSection(style);
    } else {
      this.tool.attachControl(true);
    }
  }
  return true;
};

/**
    * Use to set the section from an externally defined plane. For showing with line pattern
    * Tool itself will be disabled when setting the plane
    *
    * @param {THREE.Vector4} cutplane - send null to clear the section
    */
proto.setSectionFromPlane = function (cutplane) {
  this.deactivate();

  if (cutplane) {
    this.tool.setSectionFromPlane(cutplane);
    this.tool.attachControl(false);
  } else {
    this.tool.clearSection();
    var prevLock = this.viewer.toolController.setIsLocked(false);
    this.enableSectionTool(false);
    this.viewer.toolController.setIsLocked(prevLock);
  }
};

/**
    * Returns the planes belonging only to the Section tool's set*
    */
proto.getSectionPlanes = function () {
  return this.tool.getSectionPlanes();
};

/**
    *
    * @param enable
    * @returns {boolean}
    * @private
    */
proto.enableSectionTool = function (enable) {
  var toolController = this.viewer.toolController,
  isActive = this.tool.isActive();

  if (enable && !isActive) {
    toolController.activateTool("section");
    if (this.sectionToolButton) {
      this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
    }
    return true;

  } else if (!enable && isActive) {
    toolController.deactivateTool("section");
    if (this.sectionToolButton) {
      this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
    }
    return true;
  }
  return false;
};

/**
    * Returns an object that reperesents the state of the section planes
    * currently applied to the viewer by this extension.
    * 
    * @param {THREE.Vector3|Object} [ignoreGlobalOffset=false]
    * 
    * @returns {Object|null}
    */
proto.getViewValues = function (ignoreGlobalOffset) {

  var boxValues = this.tool.getSectionBoxValues(ignoreGlobalOffset);
  if (boxValues)
  return boxValues;

  var planeValues = this.tool.getSectionPlaneValues(ignoreGlobalOffset);
  if (planeValues)
  return planeValues;

  return null;
};

/**
    * Gets the extension state as a plain object. Invoked automatically by viewer.getState()
    * @param {object} viewerState - Object to inject extension values.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#getState
    */
proto.getState = function (viewerState) {
  if (!this.viewer.model || this.viewer.model.is2d()) {
    return;
  }

  viewerState.cutplanes = viewerState.cutplanes || [];
  var planes = this.tool.getSectionPlaneSet();
  for (var i = 0; i < planes.length; i++) {
    viewerState.cutplanes.push(planes[i].toArray());
  }
};

/**
    * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()
    * @param {object} viewerState - Viewer state.
    * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).
    * @returns {boolean} True if restore operation was successful.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#restoreState
    */
proto.restoreState = function (viewerState, immediate) {
  this.setSectionFromPlane(null); // Unload any existing planes first

  var cutplanes = this.getSectionPlanes();
  if (cutplanes.length === 1) {
    this.setSectionFromPlane(cutplanes[0]);
  }

  return true;
};

/**
    * @private
    */
proto.onCutPlanesChanged = function () /*event*/{
  this.tool.notifyCutplanesChanged();
};

/**
    * Set a section box around the passed in THREE.Box3.
    * This method will also enable the section tool.
    * @param {THREE.Box3} box - used to set the section box.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionBox
    */
proto.setSectionBox = function (box) {
  if (!box) return;
  this.enableSectionTool(true);
  if (this.tool.setSectionBox(box)) {
    this.activeStatus = true;
    this.viewer.clearSelection();
  } else {
    this.enableSectionTool(false);
  }
};

/**
    * Place a section plane on the Intersection.
    * This method will also enable the section tool.
    * @param {Three.Vector3} normal - plane normal.
    * @param {Three.Vector3} position - position to place the plane.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#setSectionPlane
    */
proto.setSectionPlane = function (normal, point) {
  if (!normal || !point) return;
  this.enableSectionTool(true);
  if (this.tool.setSectionPlane(normal, point)) {
    this.activeStatus = true;
    this.viewer.clearSelection();
  } else {
    this.enableSectionTool(false);
  }
};

/**
    * @private
    */
proto.onViewerSetView = function () /*event*/{
  this.deactivate();
};

/***
    * @private
    */
proto.onToolbarCreated = function (toolbar) {

  var AVU = Autodesk.Viewing.UI;

  this.sectionToolButton = new AVU.ComboButton("toolbar-sectionTool");
  this.sectionToolButton.setToolTip('Section analysis');
  this.sectionToolButton.setIcon("adsk-icon-section-analysis");
  this.createSubmenu(this.sectionToolButton);

  // make sure inspect tools is visible
  var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

  // place section tool before reset tool
  if (modelTools) {
    var resetTool = modelTools.getControl("toolbar-resetTool");
    if (resetTool) {
      modelTools.addControl(this.sectionToolButton, { index: modelTools.indexOf(resetTool.getId()) });
    } else {
      modelTools.addControl(this.sectionToolButton, { index: 0 });
    }
  }
};

/**
    *
    * @param parentButton
    * @private
    */
proto.createSubmenu = function (parentButton)
{
  var that = this;
  var viewer = this.viewer;
  var AVU = Autodesk.Viewing.UI;

  function createNavToggler(button, name) {
    return function () {
      var state = button.getState();
      var enable = function enable() {
        if (button instanceof AVU.ComboButton === false) {
          that.activate(name);
        } else {
          that.enableSectionTool(true);
          that.tool.attachControl(true);
        }
      };

      if (state === AVU.Button.State.INACTIVE) {
        button.setState(AVU.Button.State.ACTIVE);
        // Long initialization may cause issues on touch enabled devices, make it async
        if (Autodesk.Viewing.isMobileDevice()) {
          setTimeout(enable, 1);
        } else {
          enable();
        }
      } else if (state === AVU.Button.State.ACTIVE) {
        button.setState(AVU.Button.State.INACTIVE);
        that.deactivate();
      }
      that.sectionStyle = name.toUpperCase();
    };
  }

  function updateSectionButtons() {
    var areVectorsEqual = function () {
      var v = new THREE.Vector3();
      return function (a, b, sqtol) {
        v.subVectors(a, b);
        return v.lengthSq() < sqtol;
      };
    }();

    var unitx = new THREE.Vector3(1, 0, 0);
    var unity = new THREE.Vector3(0, 1, 0);
    var unitz = new THREE.Vector3(0, 0, 1);
    var right = viewer.autocam.getWorldRightVector();
    var up = viewer.autocam.getWorldUpVector();
    var front = viewer.autocam.getWorldFrontVector();

    var tol = 0.0001;
    if (areVectorsEqual(up, unitx, tol)) {
      that.sectionYButton.setIcon("adsk-icon-plane-x");
    } else if (areVectorsEqual(up, unitz, tol)) {
      that.sectionYButton.setIcon("adsk-icon-plane-z");
    } else {
      that.sectionYButton.setIcon("adsk-icon-plane-y");
    }

    if (areVectorsEqual(right, unity, tol)) {
      that.sectionXButton.setIcon("adsk-icon-plane-y");
    } else if (areVectorsEqual(right, unitz, tol)) {
      that.sectionXButton.setIcon("adsk-icon-plane-z");
    } else {
      that.sectionXButton.setIcon("adsk-icon-plane-x");
    }

    if (areVectorsEqual(front, unitx, tol)) {
      that.sectionZButton.setIcon("adsk-icon-plane-x");
    } else if (areVectorsEqual(front, unity, tol)) {
      that.sectionZButton.setIcon("adsk-icon-plane-y");
    } else {
      that.sectionZButton.setIcon("adsk-icon-plane-z");
    }

    viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
  }

  var sectionXButton = this.sectionXButton = new AVU.Button("toolbar-sectionTool-x");
  sectionXButton.setToolTip('Add X plane');
  sectionXButton.setIcon("adsk-icon-plane-x");
  sectionXButton.onClick = createNavToggler(sectionXButton, 'x');
  parentButton.addControl(sectionXButton);

  var sectionYButton = this.sectionYButton = new AVU.Button("toolbar-sectionTool-y");
  sectionYButton.setToolTip('Add Y plane');
  sectionYButton.setIcon("adsk-icon-plane-y");
  sectionYButton.onClick = createNavToggler(sectionYButton, 'y');
  parentButton.addControl(sectionYButton);

  var sectionZButton = this.sectionZButton = new AVU.Button("toolbar-sectionTool-z");
  sectionZButton.setToolTip('Add Z plane');
  sectionZButton.setIcon("adsk-icon-plane-z");
  sectionZButton.onClick = createNavToggler(sectionZButton, 'z');
  parentButton.addControl(sectionZButton);

  var sectionBoxButton = this.sectionBoxButton = new AVU.Button("toolbar-sectionTool-box");
  sectionBoxButton.setToolTip('Add box');
  sectionBoxButton.setIcon("adsk-icon-box");
  sectionBoxButton.onClick = createNavToggler(sectionBoxButton, 'box');
  parentButton.addControl(sectionBoxButton);

  viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
};

/**
    * @private
    */
proto.destroyUI = function () {

  if (this.sectionToolButton) {
    this.sectionToolButton.removeFromParent();
    this.sectionToolButton = null;
  }
};

/**
    * Activates a section plane for user to interact with.
    * It performs the same action as the UI button.
    * 
    * @param {string} mode - Accepted values are 'x', 'y', 'z' and 'box' (in lowercase)
    * @returns {boolean} - true if the activation was successful.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#activate
    */
proto.activate = function (mode) {
  if (this.activeStatus && this.mode === mode) {
    return;
  }
  this.enableSectionTool(true);
  switch (mode) {
    default:
    case 'x':
      this.tool.setSection('X');
      this.mode = 'x';
      break;
    case 'y':
      this.tool.setSection('Y');
      this.mode = 'y';
      break;
    case 'z':
      this.tool.setSection('Z');
      this.mode = 'z';
      break;
    case 'box':
      this.tool.setSection('BOX');
      this.mode = 'box';
      break;}

  this.activeStatus = true;
  return true;
};

/**
    * Removes the section plane/box from the 3D canvas.
    * @alias Autodesk.Viewing.Extensions.SectionExtension#deactivate
    * @returns {boolean} - returns true if deactivated, false otherwise.
    */
proto.deactivate = function () {
  if (this.activeStatus) {
    this.enableSectionTool(false);
    this.activeStatus = false;
    this.tool.setActiveMode("");
    return true;
  }
  return false;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Section', SectionExtension);

/***/ }),

/***/ "./extensions/Section/SectionTool.js":
/*!*******************************************!*\
  !*** ./extensions/Section/SectionTool.js ***!
  \*******************************************/
/*! exports provided: SectionTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SectionTool", function() { return SectionTool; });
/* harmony import */ var _thirdparty_three_js_TransformControls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../thirdparty/three.js/TransformControls */ "./thirdparty/three.js/TransformControls.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter) {if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;}}


// Declared at the bottom, inside a function.
var SectionMeshClass = null;

/**
                              * Tool that provides visual controls for the user to change the cutplane's position and angle.
                              * It can (and should) be hooked to [ToolController's registerTool]{@Autodesk.Viewing.ToolController#registerTool}
                              *
                              * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer3D instance
                              * @param {Object} config - Configuration values
                              * @param {Object} options.tintColor - Object containing attributes r, g, b in the range [0..1]
                              * @param {Number} options.tintIntensity - Value range [0..1]
                              * @constructor
                              */
var SectionTool = function SectionTool(viewer, options)
{
  var _viewer = viewer.impl;

  var _names = ["section"];
  var _active = false;

  var _isDragging = false;
  var _boxChanged = false;
  var _isPlaneOn = true;
  var _tintColor = options.tintColor;
  var _tintIntensity = options.tintIntensity;

  var _transRotControl;
  var _transControl;

  var _trcOffset;
  var _sectionGroups = [];
  var _sectionPlanes = [];
  var _sectionPicker = [];
  var _activeMode = "";
  var _overlayName = "gizmo";
  var _touchType = null;
  var _initialized = false;
  var _visibleAtFirst = true;
  var _outlineIndices = [[0, 1], [1, 3], [3, 2], [2, 0]];
  var _priority = 70;
  var _selectionOpacity = 0.25;
  var _selectionColor = 0x287EEA;

  Object(_thirdparty_three_js_TransformControls__WEBPACK_IMPORTED_MODULE_0__["init_TransformGizmos"])();
  init_SectionMesh();

  function initControl() {

    if (_initialized)
    return;

    _transRotControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "transrotate");
    _transRotControl.addEventListener('change', updateViewer);
    _transRotControl.setSnap(Math.PI / 2, Math.PI / 36); // snap to 90 degs within 5 degs range

    _transControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "translate");
    _transControl.addEventListener('change', updateViewer);

    // add to overlay scene
    if (_viewer.overlayScenes[_overlayName] === undefined) {
      _viewer.createOverlayScene(_overlayName);
    }
    _viewer.addOverlay(_overlayName, _transRotControl);
    _viewer.addOverlay(_overlayName, _transControl);

    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
    viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
    viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
    viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);

    _initialized = true;
  }

  function deinitControl() {

    if (!_initialized)
    return;

    _viewer.removeOverlay(_overlayName, _transRotControl);
    _transRotControl.removeEventListener('change', updateViewer);
    _transRotControl = null;
    _viewer.removeOverlay(_overlayName, _transControl);
    _transControl.removeEventListener('change', updateViewer);
    _transControl = null;
    _viewer.removeOverlayScene(_overlayName);

    viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
    viewer.removeEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
    viewer.removeEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
    viewer.removeEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);

    _initialized = false;
  }

  function updateViewer() {
    _viewer.invalidate(false, false, true);
  }

  function updateControls() {
    if (_transRotControl) {
      _transRotControl.update();
    }
    if (_transControl) {
      _transControl.update();
    }
  }

  function updateSections() {
    if (_active && _sectionPlanes.length === 1) {
      updatePlaneMeshes(true);
      updateControls();
      updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
    }
  }

  /*function mix(a, b, val) {
        return a * (1.0 - val) + b * val;
    }*/

  function getDiffuseColor(material) {
    return material && material.color || new THREE.Color(0xffffff);
  }

  /*function getSpecularColor(material) {
        return (material && material.specular) || new THREE.Color(0xffffff);
    }
     function tintColor(c) {
        var intensity = Autodesk.Viewing.Extensions.Section.tintIntensity;
        var tc = _tintColor;
        c.r = mix(c.r, tc.r, intensity);
        c.g = mix(c.g, tc.g, intensity);
        c.b = mix(c.b, tc.b, intensity);
    }*/


  // Object used to iterator all fragments in all dbids in all models in a scene
  // _timeSlice is the time in milliseconds before the iterator will allow itself
  // to be interrupted. _sliceDelay is the time in milliseconds the iterator delays
  // before starting a new time slice. The default values are 15 and 0 respectively.
  // I did some experiments and it seemed like these values worked pretty well.
  // _sliceDelay doesn't seem to matter very much, but making _timeSlice much
  // larger will cause highlights to look jerky.
  function FragmentIterator(_timeSlice, _sliceDelay) {

    var _capTimer = 0; // Timer used to delay time slices
    var _callback; // Callback for each fragment
    var _models; // Array of models in the scene
    var _curModel; // Current model
    var _dbIds = []; // Database ids for the current model
    var _fragIds = []; // Fragment ids for the current database id
    var _instanceTree; // Instance tree for current model
    var _m; // Current index in _models
    var _d; // Current index in _dbIds
    var _f; // Current index in _fragIds

    // Default value for _timeSlize and _sliceDelay
    _timeSlice = _timeSlice || 15;
    _sliceDelay = _sliceDelay || 0;

    // Start the iterator
    // models is the array of models to iterate
    // delay is a delay to start the iteration. < 0 starts without any delay
    // callback is the callback for each fragment:
    //   callback(fragId, dbId, model, lastFrag)
    // lastFrag is a boolean that is true when fragId is the last fragment for dbId.
    this.start = function (models, delay, callback) {
      reset(models);

      _callback = callback;
      if (callback) {
        if (delay >= 0)
        _capTimer = setTimeout(doIteration, delay);else

        doIteration();
      }
    };

    // Reset the iterator, this is so we can clear the manager at the end.
    function reset(models) {
      if (_capTimer)
      clearTimeout(_capTimer);
      _capTimer = 0;
      _models = models;
      _dbIds.length = 0;
      _fragIds.length = 0;
      _instanceTree = null;
      _m = -1;
      _d = 0;
      _f = 0;
    }

    // Do a single time slice
    function doIteration() {
      _capTimer = 0;
      var endTime = performance.now() + _timeSlice;
      while (performance.now() < endTime) {
        // If we are done, then return
        if (!next()) {
          // The cap scene is in sceneAfter, so we need to redraw the model to see the caps.
          // LMV-2571 - clear the render, as otherwise we will draw transparent objects atop themselves.
          _viewer.invalidate(true, true);
          // Clear everything when we are done
          reset(null);
          return;
        }

        // Call the call back function
        _callback(_fragIds[_f], _dbIds[_d], _curModel, _f + 1 >= _fragIds.length, !_models || _m >= _models.length);
      }

      // Schedule the next time slice
      _capTimer = setTimeout(doIteration, _sliceDelay);
    }

    // Advance to the next model in _models
    function nextModel() {
      // Continue processing the next model in _models
      if (_models && _m < _models.length) {
        // Go to next model
        while (++_m < _models.length) {
          _instanceTree = _models[_m].getInstanceTree();
          // Only process the model, if it has a fragment map
          if (_instanceTree) {
            // Get the list of dbIds.
            _dbIds.length = 0;
            _instanceTree.enumNodeChildren(_models[_m].getRootId(), function (dbId) {
              _dbIds.push(dbId);
            }, true);
            // Only process the model if we got some ids
            if (_dbIds.length > 0) {
              // Set the current model and newly loaded dbIds
              _curModel = _models[_m];
              return _curModel;
            }
          }
        }
      }

      // Done clear the current model and new loaded dbIds
      _curModel = null;

      // End of the models
      return false;
    }

    // Advance to the next database id
    function nextDbId() {
      // At the end, return false
      if (_d >= _dbIds.length)
      return false;

      // Go to next database id
      while (++_d < _dbIds.length) {
        var dbId = _dbIds[_d];
        // Only process dbIds that are not hidden and not off
        if (!_instanceTree.isNodeHidden(dbId) && !_instanceTree.isNodeOff(dbId)) {
          //All fragments that belong to the same node make part of the
          //same object so we have to accumulate all their intersections into one list
          _fragIds.length = 0;
          _instanceTree.enumNodeFragments(dbId, function (fragId) {
            _fragIds.push(fragId);
          }, false);
          // Only process the database id if there are some fragments
          if (_fragIds.length > 0)
          return true;
        }
      }

      // end of the database ids
      return false;
    }

    // Advance to the next fragment
    function next() {
      // If we are not a the end of the fragment list, then process it
      if (++_f < _fragIds.length)
      return true;

      // Start the fragment list at the beginning
      _f = 0;
      for (;;) {
        // If we have more database ids, then process them
        if (nextDbId())
        return true;
        // If we don't have another model, then we are done
        if (!nextModel())
        return false;
        // restart the database ids for the new model
        _d = -1;
      }
    }
  }

  // Use the same fragment iterator for all fragments
  var _fragIterator = new FragmentIterator();

  function updateCapMeshes(plane) {

    var cg = Autodesk.Viewing.Extensions.CompGeom;

    var oldsection = _viewer.sceneAfter.getObjectByName("section");
    if (oldsection)
    _viewer.sceneAfter.remove(oldsection);

    var section = new THREE.Object3D();
    section.name = "section";
    _viewer.sceneAfter.add(section);

    var section3D = new THREE.Object3D();
    section.add(section3D);
    var section2D = new THREE.Object3D();
    section.add(section2D);

    var avp = Autodesk.Viewing.Private;


    var toPlaneCoords = cg.makePlaneBasis(plane);
    var fromPaneCoords = new THREE.Matrix4().getInverse(toPlaneCoords);

    var mat2dname = _viewer.matman().create2DMaterial(null, { skipCircles: true, skipEllipticals: true, isScreenSpace: true }, false, false);
    var mat2d = _viewer.matman().findMaterial(null, mat2dname);
    mat2d.transparent = true;
    mat2d.depthTest = true;
    mat2d.polygonOffset = true;
    mat2d.polygonOffsetFactor = -1;
    mat2d.polygonOffsetUnits = 0.1; // 1.0 is usually way too high, see LMV-1072
    mat2d.cutplanes = _otherCutPlanes; // make sure that cap meshes respect cutplanes from other tools

    var box = new THREE.Box3();

    //var worldBox = _viewer.getVisibleBounds(true);   

    //some heuristic for line width of the section outline based on model size.
    //half a percent of the model size is what we do here.
    //var lineWidth = 0.5 * 5e-5 * worldBox.size().length();

    var models = _viewer.modelQueue().getModels();

    var intersects = [];
    var material;

    function removeMesh(object, modelId, dbId, disposeMaterial) {
      var child = object.children.find(function (mesh) {
        return mesh.modelId == modelId && mesh.dbId == dbId;
      });
      if (child) {
        object.remove(child);
        if (child.geometry)
        child.geometry.dispose();
        if (disposeMaterial && child.material)
        child.material.dispose();
      }
    }

    // Start iterating the fragments
    _fragIterator.start(models, 50, function (fragId, dbId, model, lastFrag) {

      // Collect intersections for this fragment
      var frags = model.getFragmentList();
      frags.getWorldBounds(fragId, box);
      if (cg.xBoxPlane(plane, box)) {
        var m = frags.getVizmesh(fragId);

        if (m.geometry && !m.geometry.is2d && !m.geometry.isLines && m.material.cutplanes) {
          material = m.material;
          cg.xMeshPlane(plane, m, intersects);
        }
      }

      // If this is the last fragment for dbId, process the intersections
      if (lastFrag) {
        if (intersects.length) {

          var bbox = new THREE.Box3();
          cg.convertToPlaneCoords(toPlaneCoords, intersects, bbox);

          //Create the 2D line geometry
          var vbb = new avp.VertexBufferBuilder(false, 8 * intersects.length);

          var color = getDiffuseColor(material);
          var r = 0 | color.r * 0.25 * 255.5;
          var g = 0 | color.g * 0.25 * 255.5;
          var b = 0 | color.b * 0.25 * 255.5;

          var c = 0xff000000 | b << 16 | g << 8 | r;


          var eset = new cg.EdgeSet(intersects, bbox, bbox.size().length() * 1e-6);
          eset.snapEdges();
          eset.sanitizeEdges();
          eset.stitchContours();

          //Create the 3D mesh
          var cset = eset.triangulate();

          //Testing code path using the fancier DCEL structure for triangulation of the section edges.
          //TODO: compare quality and performance before switching to this and retiring the EdgeSet code path
          /*
                              var dcel = new DCEL(bbox, bbox.size().length() * 1e-6);
                              intersects.forEach(e => {
                                  dcel.addDirectedEdge(e.v1.x, e.v1.y, e.v2.x, e.v2.y, true, dbId);
                              });
          
                              dcel.finalize(true);
          
                              let cset = dcel.closedAreas[0];
          */

          if (cset) {
            /*
                                         if (cset.triangulationFailed)
                                             c = 0xffffff00;
                     */

            for (var j = 0; j < cset.contours.length; j++) {

              var cntr = cset.contours[j];

              for (var k = 1; k < cntr.length; k++) {
                var pt1 = cset.pts[cntr[k - 1]];
                var pt2 = cset.pts[cntr[k]];
                vbb.addSegment(pt1.x, pt1.y, pt2.x, pt2.y, 0, -2.0, /*isClosed ? c : rc*/c, dbId, 0);
              }

            }


            var mdata = { mesh: vbb.toMesh() };

            avp.BufferGeometryUtils.meshToGeometry(mdata);

            var bg2d = mdata.geometry;
            bg2d.streamingDraw = true;
            bg2d.streamingIndex = true;

            var mesh2d = new THREE.Mesh(bg2d, mat2d);

            mesh2d.matrix.copy(fromPaneCoords);
            mesh2d.matrixAutoUpdate = false;
            mesh2d.frustumCulled = false;
            mesh2d.modelId = model.id; // So we can look it up later
            mesh2d.dbId = dbId;
            section2D.add(mesh2d);

            //Create triangulated capping polygon
            {
              if (!cset.triangulationFailed) {

                var bg = cset.toPolygonMesh(material.packedNormals);

                var mat = _viewer.matman().cloneMaterial(material, model);

                mat.packedNormals = material.packedNormals;
                mat.cutplanes = _otherCutPlanes; // make sure that cap meshes respect cutplanes from other tools
                mat.side = THREE.FrontSide;
                mat.depthTest = true;
                mat.map = null;
                mat.bumpMap = null;
                mat.normalMap = null;
                mat.alphaMap = null;
                mat.specularMap = null;
                mat.transparent = false;
                mat.depthWrite = true;
                mat.hatchPattern = true;
                mat.needsUpdate = true;

                var angle = (material.id + 2) * Math.PI * 0.125;
                var tan = Math.tan(angle);
                mat.hatchParams = new THREE.Vector2(tan, 10.0);
                mat.hatchTintColor = _tintColor;
                mat.hatchTintIntensity = _tintIntensity;

                // If the material is prism, clear all the map definitions.
                if (mat.prismType != null) {
                  mat.defines = {};
                  mat.defines[mat.prismType.toUpperCase()] = "";
                  if (mat.prismType == "PrismWood") {
                    mat.defines["NO_UVW"] = "";
                  }
                }

                var capmesh = new THREE.Mesh(bg, mat);
                capmesh.matrix.copy(fromPaneCoords);
                capmesh.matrixAutoUpdate = false;
                capmesh.modelId = model.id; // So we can look it up later
                capmesh.dbId = dbId;
                capmesh.fragId = intersects.fragId;

                section3D.add(capmesh);
              }

            }

          }
        }

        // Clear intersections for the next dbId
        intersects.length = 0;
      } // last Fragment for dbId

    }); //_fragIterator.start

  }

  // We use an own cut plane set to distinguish our own cut planes from others.
  var _ownCutPlaneSet = 'Autodesk.Viewing.Extension.Section.SectionTool';

  // Make sure that the viewer always uses the SectionTool's plane to adjust 2D rendering resolution.
  _viewer.setCutPlaneSetFor2DRendering(_ownCutPlaneSet);

  // Keep track of cutplanes that are not our own, because we have to apply them to our cap meshes
  var _otherCutPlanes = [];

  // Trigger update of cap mesh materials if number of cutplanes have changed by other tools
  function updateCapMaterials() {

    // apply cutplanes to all active cap meshes
    var section = _viewer.sceneAfter.getObjectByName("section");
    if (!section) {
      return;
    }

    section.traverse(function (obj) {
      // we only care for THREE.Mesh with material
      if (!obj instanceof THREE.Mesh || !obj.material) {
        return;
      }
      obj.material.needsUpdate = true;
    });
  }

  function createPlaneMesh(plane, bbox) {
    var quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);
    var geometry;
    var size;

    if (bbox) {
      // project bbox to set plane size
      var ptMax = plane.projectPoint(bbox.max);
      var ptMin = plane.projectPoint(bbox.min);
      var invQuat = quat.clone().inverse();
      ptMax.applyQuaternion(invQuat);
      ptMin.applyQuaternion(invQuat);
      size = new THREE.Vector3().subVectors(ptMax, ptMin);
      geometry = new THREE.PlaneBufferGeometry(size.x, size.y);
    } else {
      // project bounding sphere
      bbox = _viewer.getVisibleBounds();
      size = 2.0 * bbox.getBoundingSphere().radius;
      geometry = new THREE.PlaneBufferGeometry(size, size);
    }

    var material = new THREE.MeshBasicMaterial({
      opacity: 0,
      color: _selectionColor,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false,
      transparent: true });


    var mesh = new SectionMeshClass(geometry, material, plane);
    var pt = plane.projectPoint(bbox.center());
    mesh.position.copy(pt);
    mesh.quaternion.multiply(quat);

    // add outlines with inverted background color
    var presetIndex = _viewer.currentLightPreset();
    presetIndex = Math.max(0, presetIndex);
    var bgColor = Autodesk.Viewing.Private.LightPresets[presetIndex].bgColorGradient;
    var color = "rgb(" + (255 - bgColor[0]) + "," + (255 - bgColor[1]) + "," + (255 - bgColor[2]) + ")";
    var lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1, depthTest: false });
    var pos = mesh.geometry.getAttribute('position');
    for (var i = 0; i < _outlineIndices.length; i++) {
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize),
      new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize));
      var line = new THREE.Line(geometry, lineMaterial);
      mesh.add(line);
      mesh.outlines.push(line);
    }

    return mesh;
  }

  function updatePlaneMeshes(rebuild) {

    traverseSections(function (child) {
      if (child instanceof SectionMeshClass) {

        var i, line, pos, pt;
        if (child.connectivity.length > 0) {
          // section box
          var minv = new THREE.Matrix4().getInverse(child.matrixWorld);
          pt = new THREE.Vector3();
          pos = child.geometry.getAttribute('position');
          for (i = 0; i < pos.length / pos.itemSize; i++) {
            var connect = child.connectivity[i];
            if (intersectPlanes(child.plane, connect[0], connect[1], pt) !== null) {
              pt.applyMatrix4(minv);
              pos.setXYZ(i, pt.x, pt.y, pt.z);
            }
          }
          pos.needsUpdate = true;
          child.geometry.computeBoundingBox();
          child.geometry.computeBoundingSphere();

          for (i = 0; i < child.outlines.length; i++) {
            line = child.outlines[i];
            line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
            line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
            line.geometry.verticesNeedUpdate = true;
          }
        } else {
          // section plane
          if (rebuild) {
            var bbox = _viewer.getVisibleBounds();
            var size = 2.0 * bbox.getBoundingSphere().radius;
            pt = child.plane.projectPoint(bbox.center());
            child.geometry = new THREE.PlaneBufferGeometry(size, size);
            child.position.copy(pt);
            pos = child.geometry.getAttribute('position');
            for (i = 0; i < child.outlines.length; i++) {
              line = child.outlines[i];
              line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
              line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
              line.geometry.verticesNeedUpdate = true;
            }
          }
        }
      }
    });
  }

  function traverseSections(callback) {
    for (var i = 0; i < _sectionGroups.length; i++) {
      _sectionGroups[i].traverse(callback);
    }
  }

  function setSectionPlanes() {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    traverseSections(function (child) {
      if (child instanceof SectionMeshClass) {
        child.update();
      }
    });
    if (_sectionPlanes.length === 1) {
      updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
    }
    _viewer.setCutPlaneSet(_ownCutPlaneSet, _sectionPlanes, fireEvent);
  }

  function showPlane(set) {
    for (var i = 0; i < _sectionGroups.length; i++) {
      _sectionGroups[i].visible = set;
    }

    if (_isPlaneOn !== set)
    updateViewer();

    _isPlaneOn = set;
  }

  function showSection(set) {
    if (set && _sectionPlanes.length > 0) {
      if (_sectionPlanes.length === 1) {
        updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
      }
      _viewer.setCutPlaneSet(_ownCutPlaneSet, _sectionPlanes);
    }
    showPlane(set);
  }

  function attachControl(control, mesh) {
    control.attach(mesh);
    control.setPosition(mesh.position);
    control.visible = true;
  }

  function checkNormal(normal) {
    // flip normal if facing inward as eye direction
    var eyeVec = _viewer.api.navigation.getEyeVector();
    if (eyeVec.dot(normal) > 0) {
      normal.negate();
    }

    return normal;
  }

  function setPlane(normal, distance) {var fireEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var obbox = _viewer.getVisibleBounds();
    var center = obbox.center();
    var group = new THREE.Group();
    // Calculate the plane signed distance using the dot product of the center point of the scene bounding box
    // and the normal vector.
    distance = distance !== undefined ? distance : -1 * center.dot(normal);
    var plane = new THREE.Plane(normal, distance);
    var mesh = createPlaneMesh(plane, null);
    group.add(mesh);
    _sectionPlanes.push(mesh.planeVec);
    _sectionGroups.push(group);
    _viewer.addOverlay(_overlayName, group);
    if (_transRotControl) {
      attachControl(_transRotControl, mesh);
      mesh.material.opacity = _selectionOpacity;
      centerPlaneArrow(mesh);
      _transRotControl.showRotationGizmos(true);
      _sectionPicker = _transRotControl.getPicker();

    }
    setSectionPlanes(fireEvent);
  }

  function getCenterPoint(mesh) {
    var middle = new THREE.Vector3();
    var geometry = mesh.geometry;

    geometry.computeBoundingBox();

    middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
    middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
    middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;

    mesh.localToWorld(middle);
    return middle;
  }

  /**
     * Places the arrow at the center of the passed in mesh.
     * @param {*} mesh 
     */
  function centerPlaneArrow(mesh) {
    if (!_transRotControl || !mesh) return false;
    // Get the center of the plane and 
    // calculate the x,y,z offset between the plane position and the plane center
    var centerOffset = getCenterPoint(mesh).sub(mesh.position);
    centerOffset.sub(_trcOffset);
    // Set the gizmo offset
    _transRotControl.setGizmoOffset(centerOffset);
    return true;
  }

  function setBox(planeSet) {
    var normals = [
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, -1, 0),
    new THREE.Vector3(0, 0, -1)];


    var connectivities = [
    [[1, 2], [1, 5], [2, 4], [4, 5]], // 0
    [[3, 5], [0, 5], [2, 3], [0, 2]], // 1
    [[1, 3], [0, 1], [3, 4], [0, 4]], // 2
    [[1, 5], [1, 2], [4, 5], [2, 4]], // 3
    [[2, 3], [0, 2], [3, 5], [0, 5]], // 4
    [[0, 1], [3, 1], [0, 4], [3, 4]] // 5
    ];

    var group = new THREE.Group();
    var obbox = _viewer.getVisibleBounds();
    var center = obbox.center();
    var bbox = new THREE.Box3(obbox.min, center);

    // Initialize from planeSet ONLY if it's an AABB.
    var loadingBox = false;
    if (planeSet && planeSet.length === 6 && planeSet[0].x === 1.0) {
      // Assume that the order on planes is the same as in Array of normals defined above
      bbox = new THREE.Box3(
      new THREE.Vector3(planeSet[3].w, planeSet[4].w, planeSet[5].w),
      new THREE.Vector3(planeSet[0].w, planeSet[1].w, planeSet[2].w));

      center = bbox.max.clone();
      loadingBox = true;
    }

    ////center = obbox.max;   // Use this to initialize the box around the model
    ////bbox = obbox.clone(); // Use this to initialize the box around the model

    var planes = [],meshes = [];
    var i, mesh;
    for (i = 0; i < normals.length; i++) {

      if (loadingBox) {
        var plane = new THREE.Plane(normals[i], planeSet[i].w);
        planes.push(plane);
      } else

      {
        var plane = new THREE.Plane(normals[i], -1 * center.dot(normals[i]));
        planes.push(plane);

        // offset plane with negative normal to form an octant
        if (i > 2) {
          var ptMax = plane.orthoPoint(bbox.max);
          var ptMin = plane.orthoPoint(bbox.min);
          var size = new THREE.Vector3().subVectors(ptMax, ptMin);
          plane.constant -= size.length();
        }
      }

      mesh = createPlaneMesh(plane, bbox);
      group.add(mesh);
      meshes.push(mesh);
      _sectionPlanes.push(mesh.planeVec);
    }

    // build connectivity
    for (i = 0; i < meshes.length; i++) {
      mesh = meshes[i];
      var connectivity = connectivities[i];
      for (var j = 0; j < connectivity.length; j++) {
        var nc = [];
        var ct = connectivity[j];
        for (var k = 0; k < ct.length; k++) {
          nc.push(planes[ct[k]]);
        }
        mesh.connectivity.push(nc);
      }
    }

    _sectionGroups.push(group);
    _viewer.addOverlay(_overlayName, group);

    setSectionPlanes();
    updatePlaneMeshes();

    var plane = _sectionGroups[0].children[0];
    attachControl(_transRotControl, plane);
    // Set the plane opacity
    plane.material.opacity = _selectionOpacity;
    centerPlaneArrow(plane);

    attachControl(_transControl, _sectionGroups[0]);
    _transRotControl.showRotationGizmos(false);
    _sectionPicker = _transRotControl.getPicker().concat(_transControl.getPicker());
    // Calculate the offset to the max point of the bounding box.
    var sectionBoxPosition = _sectionGroups[0].position.clone();
    var cornerOffset = sectionBoxPosition.sub(center.clone());
    _transControl.setGizmoOffset(cornerOffset);
  }

  var intersectPlanes = function () {
    var m = new THREE.Matrix3();
    var n23 = new THREE.Vector3();
    var n31 = new THREE.Vector3();
    var n12 = new THREE.Vector3();
    return function (plane1, plane2, plane3, optionalTarget) {
      m.set(plane1.normal.x, plane1.normal.y, plane1.normal.z,
      plane2.normal.x, plane2.normal.y, plane2.normal.z,
      plane3.normal.x, plane3.normal.y, plane3.normal.z);

      var det = m.determinant();
      if (det === 0) return null;

      n23.crossVectors(plane2.normal, plane3.normal).multiplyScalar(-plane1.constant);
      n31.crossVectors(plane3.normal, plane1.normal).multiplyScalar(-plane2.constant);
      n12.crossVectors(plane1.normal, plane2.normal).multiplyScalar(-plane3.constant);

      var result = optionalTarget || new THREE.Vector3();
      return result.copy(n23).add(n31).add(n12).divideScalar(det);
    };
  }();

  var intersectObjects = function intersectObjects(pointer, objects, recursive) {
    return THREE.TransformControls.intersectObjects(pointer.canvasX, pointer.canvasY, objects, _viewer.camera, recursive);
  };

  // public functions

  /**
   * When active, the geometry will be sectioned by the current set cut plane.
   * @returns {boolean}
   */
  this.isActive = function () {
    return _active;
  };

  /**
      * Returns the signed distance of the sectioning plane from the origin
      * @returns {Number} distance. Null distance is returned if there is no hit found from raycast
      */
  this.getSectionDistance = function (normal) {
    // Find a target point in the direction of the camera 
    var eyeVec = _viewer.api.navigation.getEyeVector();
    var hit = _viewer.rayIntersect(new THREE.Ray(_viewer.camera.position, eyeVec));
    // DIstance
    return hit && hit.intersectPoint && -1 * hit.intersectPoint.dot(normal);
  };

  /**
      * Enables the cut planes that were created by the viewer.setCutPlanes() function.
      * @param {boolean} [fireEvent] - if set to false the av.CUTPLANES_CHANGE_EVENT event will not be fired.
      */
  this.setViewerSection = function () {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this.clearSection(fireEvent);
    var normal;
    // Attempt to initialize the tool with a plane that is already set.
    var planeSet = _viewer.getCutPlaneSet('__set_view');
    if (planeSet.length !== 1) return;

    _transRotControl.clientScale = 1;
    var v4 = planeSet[0];
    var normal = new THREE.Vector3(v4.x, v4.y, v4.z);
    var distance = v4.w;
    setPlane(normal, distance, fireEvent);
    _activeMode = 'SET_VIEW_PLANE';
    // Clear sections from Viewer3D::setView
    _viewer.setCutPlaneSet('__set_view', undefined, fireEvent);
  };



  /**
      * Facilitates the initialization of a cut plane
      * 
      * @param {String} name - Either 'X', 'Y', 'Z' or 'BOX'
      */
  this.setSection = function (name) {
    this.clearSection();
    _trcOffset = new THREE.Vector3();
    var normal, distance;
    _transRotControl.clientScale = 1;

    // Attempt to initialize the tool with a plane that is already set.
    var planeSet = _viewer.getCutPlaneSet('__set_view');
    if (planeSet.length === 1 && name !== 'BOX' && name !== 'OBJ_SET_VIEW_PLANE') {
      name = 'SET_VIEW_PLANE';
    }

    switch (name) {
      case 'X':
        normal = new THREE.Vector3(1, 0, 0);
        distance = this.getSectionDistance(normal);
        setPlane(checkNormal(normal), distance);
        break;
      case 'Y':
        normal = new THREE.Vector3(0, 1, 0);
        distance = this.getSectionDistance(normal);
        setPlane(checkNormal(normal), distance);
        break;
      case 'Z':
        normal = new THREE.Vector3(0, 0, 1);
        distance = this.getSectionDistance(normal);
        setPlane(checkNormal(normal), distance);
        break;
      case 'OBJ_SET_VIEW_PLANE':
      case 'SET_VIEW_PLANE':
        var v4 = planeSet[0];
        normal = new THREE.Vector3(v4.x, v4.y, v4.z);
        setPlane(normal, v4.w);
        break;
      case 'OBJ_BOX':
      case 'BOX':
        setBox(planeSet);
        _transRotControl.clientScale = 2;
        this.recomputePivot();
        break;}

    _activeMode = name;

    // Clear sections from Viewer3D::setView
    _viewer.setCutPlaneSet('__set_view', undefined);
  };

  /**
      * Facilitates the initialization of a cut plane from a normal and distance
      *
      * @param {THREE.Vector4} normal (x,y,z) and distance (w)
      * @param {Number} distance
      */
  this.setSectionFromPlane = function (cutplane) {
    this.clearSection();
    setPlane(new THREE.Vector3(cutplane.x, cutplane.y, cutplane.z), cutplane.w);
    _activeMode = "";

    // Clear sections from Viewer3D::setView
    _viewer.setCutPlaneSet('__set_view', undefined);
  };

  /**
      * Set the active mode
      * @param {string} [name] - active mode name
      * @private
      */
  this.setActiveMode = function (name) {
    _activeMode = name || "";
  };

  /**
      * Removes any (and all) currently set cut plane(s).
      * @param {boolean} [fireEvent] - if set to false the av.CUTPLANES_CHANGE_EVENT event will not be fired.
      */
  this.clearSection = function () {var fireEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (_transRotControl)
    _transRotControl.detach();

    if (_transControl)
    _transControl.detach();

    // remove all sections
    while (_sectionPlanes.length > 0) {
      _sectionPlanes.pop();
    }

    while (_sectionGroups.length > 0) {
      var group = _sectionGroups.pop();
      _viewer.removeOverlay(_overlayName, group);
    }

    _fragIterator.start(null); // Shutdown iterator        
    var oldsection = _viewer.sceneAfter.getObjectByName("section");
    if (oldsection)
    _viewer.sceneAfter.remove(oldsection);

    _viewer.setCutPlaneSet(_ownCutPlaneSet, null, fireEvent);
  };

  this.isPlaneOn = function () {
    return _isPlaneOn;
  };

  this.showPlane = function (set) {
    showPlane(set);
  };

  /**
      * Whether translation and rotation controls are visible or not.
      * @param {Boolean} set
      */
  this.attachControl = function (set) {
    if (!_transRotControl || !_transControl) {
      return;
    }

    if (set) {
      attachControl(_transRotControl, _sectionGroups[0].children[0]);
      _transRotControl.highlight();
      if (_activeMode === 'BOX')
      attachControl(_transControl, _sectionGroups[0]);
    } else {
      _transRotControl.detach();
      _transControl.detach();
    }
  };

  /**
      * Invokes setSection with the last set of parameters used.
      */
  this.resetSection = function () {
    this.setSection(_activeMode);
  };

  // tool interface

  this.getNames = function () {
    return _names;
  };

  this.getName = function () {
    return _names[0];
  };

  this.register = function () {
  };

  this.deregister = function () {
    this.clearSection();
    deinitControl();
  };

  this.getPriority = function () {
    return _priority;
  };

  /**
      * [ToolInterface] Activates the tool
      * @param {String} name - unused
      */
  this.activate = function () /*name*/{

    initControl();

    _active = true;
    _isDragging = false;
    _visibleAtFirst = true;

    // keep only one section all the time per design
    _sectionPlanes = _sectionPlanes || [];

    showSection(true);
  };

  /**
      * [ToolInterface] Deactivates the tool
      * @param {String} name - unused
      */
  this.deactivate = function () /*name*/{
    _active = false;
    _isDragging = false;

    _fragIterator.start(null); // Shutdown iterator        
    var oldsection = _viewer.sceneAfter.getObjectByName("section");
    if (oldsection)
    _viewer.sceneAfter.remove(oldsection);


    showSection(false);
    _viewer.setCutPlaneSet(_ownCutPlaneSet);
    _transRotControl.detach();
    _transControl.detach();
  };

  this.update = function () /*highResTimestamp*/{
    return false;
  };

  this.handleSingleClick = function (event /*, button*/) {
    var pointer = event;
    var result = intersectObjects(pointer, _sectionGroups[0].children);
    _sectionGroups[0].children.forEach(function (child) {
      child.material.opacity = 0;
    });

    if (result) {
      attachControl(_transRotControl, result.object);
      _transRotControl.highlight();
      result.object.material.opacity = _selectionOpacity;
      centerPlaneArrow(result.object);
      updateViewer();
    }

    return false;
  };

  this.handleDoubleClick = function () /*event, button*/{
    return false;
  };

  this.handleSingleTap = function (event) {
    return this.handleSingleClick(event, 0);
  };

  this.handleDoubleTap = function () /*event*/{
    return false;
  };

  this.handleKeyDown = function () /*event, keyCode*/{
    return false;
  };

  this.handleKeyUp = function () /*event, keyCode*/{
    return false;
  };

  this.handleWheelInput = function () /*delta*/{
    return false;
  };

  this.handleButtonDown = function (event /*, button*/) {
    _isDragging = true;
    if (_transControl.onPointerDown(event))
    return true;
    return _transRotControl.onPointerDown(event);
  };

  this.handleButtonUp = function (event /*, button*/) {
    _isDragging = false;
    if (_boxChanged) {
      _boxChanged = false;
      this.recomputePivot();
    }
    if (_transControl.onPointerUp(event))
    return true;
    return _transRotControl.onPointerUp(event);
  };

  this.handleMouseMove = function (event) {
    var oldTransControlPos = _transControl.object ? new THREE.Vector3().copy(_transControl.object.position) : null;
    // var oldMaxPoint = _transControl.object ? getMaxPoint(_transControl.object) : null;
    if (_isDragging) {
      if (_transControl.onPointerMove(event)) {
        _boxChanged = true;
        setSectionPlanes();
        _transRotControl.update();
        // Keep track of the section box offset
        var boxOffset = new THREE.Vector3().copy(_transControl.object.position).sub(oldTransControlPos);
        // Add the box offset to the section plane offset
        _trcOffset.add(boxOffset);
        return true;
      }
      if (_transRotControl.onPointerMove(event)) {
        _boxChanged = true;
        setSectionPlanes();
        updatePlaneMeshes();
        // TODO: Try to position the triad to the max corner of the section box when moving the plane arrow.
        // Currently, it is positioned at the max point of the section box.
        return true;
      }
    }

    _transControl.visible = _transControl.object !== undefined;

    if (event.pointerType !== 'touch') {
      var pointer = event;
      var result = intersectObjects(pointer, _sectionGroups[0].children);
      if (result) {
        _visibleAtFirst = false;
      }

      // show gizmo + plane when intersecting on non-touch 
      var visible = _visibleAtFirst || result || intersectObjects(pointer, _sectionPicker, true) ? true : false;
      _transRotControl.visible = visible;
      _transControl.visible = _transControl.visible && visible;
      showPlane(visible);
    }

    if (_transControl.onPointerHover(event))
    return true;

    return _transRotControl.onPointerHover(event);
  };

  this.handleGesture = function (event) {
    switch (event.type) {
      case "dragstart":
        _touchType = "drag";
        // Single touch, fake the mouse for now...
        return this.handleButtonDown(event, 0);

      case "dragmove":
        return _touchType === "drag" ? this.handleMouseMove(event) : false;

      case "dragend":
        if (_touchType === "drag") {
          _touchType = null;
          return this.handleButtonUp(event, 0);
        }
        return false;}

    return false;
  };

  this.handleBlur = function () /*event*/{
    return false;
  };

  this.handleResize = function () {
  };

  this.handlePressHold = function () /*event*/{
    return true;
  };

  this.recomputePivot = function () {

    var values = this.getSectionBoxValues(true);
    if (!values) return;

    var aabb = values.sectionBox;

    _viewer.api.navigation.setPivotPoint(new THREE.Vector3(
    aabb[0] + (aabb[3] - aabb[0]) * 0.5,
    aabb[1] + (aabb[4] - aabb[1]) * 0.5,
    aabb[2] + (aabb[5] - aabb[2]) * 0.5));

  };

  this.getSectionBoxValues = function (ignoreGlobalOffset) {

    var group = _sectionGroups[0];
    if (!group) {
      return null;
    }

    var planes = group.children;
    if (planes.length < 6) {
      return null;
    }

    var right = planes[0].position.x;
    var top = planes[1].position.y;
    var front = planes[2].position.z;
    var left = planes[3].position.x;
    var bttm = planes[4].position.y;
    var back = planes[5].position.z;

    var off = { x: 0, y: 0, z: 0 };
    if (!ignoreGlobalOffset) {
      off = _viewer.model.getData().globalOffset || off;
    }

    var aabb = [
    Math.min(left, right) + off.x,
    Math.min(top, bttm) + off.y,
    Math.min(front, back) + off.z,
    Math.max(left, right) + off.x,
    Math.max(top, bttm) + off.y,
    Math.max(front, back) + off.z];


    // Box doesn't support rotation at the moment.
    // Will have to take it into account if that becomes a feature.
    var transform = new THREE.Matrix4().identity().toArray();

    return {
      sectionBox: aabb,
      sectionBoxTransform: transform };

  };

  this.getSectionPlaneValues = function (ignoreGlobalOffset) {

    var group = _sectionGroups[0];
    if (!group) {
      return null;
    }

    var planes = group.children;
    if (planes.length !== 1) {
      return null;
    }

    var off = { x: 0, y: 0, z: 0 };
    if (!ignoreGlobalOffset) {
      off = _viewer.model.getData().globalOffset || off;
    }

    var plane = planes[0].plane;
    var constant = plane.constant - THREE.Vector3.prototype.dot.call(off, plane.normal);

    return {
      sectionPlane: [
      plane.normal.x,
      plane.normal.y,
      plane.normal.z,
      constant] };


  };

  this.getSectionPlaneSet = function () {
    return _viewer.getCutPlaneSet(_ownCutPlaneSet);
  };

  this.getSectionPlanes = function () {
    var result = [];

    // When restoring a viewer state it is put in __set_view, so return from that set as well
    var setsNames = ['__set_view', _ownCutPlaneSet];

    setsNames.forEach(function (name) {
      var cp = _viewer.getCutPlaneSet(name);
      if (cp.length > 0) {
        result.push.apply(result, _toConsumableArray(cp));
      }
    });

    return result;
  };

  // Called by viewer if any cutplanes are modified. It makes sure that cutplanes controlled by separate tools
  // (with own cutplane sets) are considered by our cap meshes.
  this.notifyCutplanesChanged = function () {

    var numCutPlanesBefore = _otherCutPlanes.length;

    // Collect all active cutplanes from other tools
    //
    // NOTE: It's essential that we don't create a new array, but just refill the same one.
    //       Since the cap meshes are created async, the cutPlaneChange event may come in the middle of
    //       the cap mesh generation. For consistency, we want all cap meshes to share the same cutplane array.
    _otherCutPlanes.length = 0;
    var cpSets = _viewer.getCutPlaneSets();
    for (var i = 0; i < cpSets.length; i++) {

      // skip our own cut planes
      var cpName = cpSets[i];
      if (cpName === _ownCutPlaneSet) {
        continue;
      }

      // add cutplanes of this set
      var cp = _viewer.getCutPlaneSet(cpName);
      for (var j = 0; j < cp.length; j++) {
        _otherCutPlanes.push(cp[j]);
      }
    }

    // Set the section tool to the viewer defined cutplane.
    if (cpSets.includes("__set_view") && _activeMode !== "" && _activeMode.indexOf("OBJ_") === -1) {
      this.setViewerSection(false);
    }

    // If the number of cutplanes changed, this requires a shader recompile of the cap materials
    if (numCutPlanesBefore !== _otherCutPlanes.length) {
      updateCapMaterials();
    }
  };

  /**
      * Set a section box around the passed in bounding box.
      * @param {THREE.Box3} box
      * @returns {boolean} - true if the section box was set
      */
  this.setSectionBox = function (box) {
    if (!box) return false;
    var name = 'OBJ_BOX';
    // Convert the bounding box to planes
    var planes = Autodesk.Viewing.Private.SceneMath.box2CutPlanes(box, box.transform);
    _activeMode = name;
    _viewer.setCutPlaneSet('__set_view', planes);
    this.setSection(name);
    return true;
  };

  /**
      * Set a section plane at the intersection position.
      * @param {Three.Vector3} normal - plane normal.
      * @param {Three.Vector3} position - position to place the plane.
      * @returns {boolean} - true if the section plane was set
      */
  this.setSectionPlane = function (normal, position) {
    if (!normal || !position) return false;
    var name = 'OBJ_SET_VIEW_PLANE';
    var distance = -1 * position.dot(normal);
    var plane = new THREE.Plane(normal, distance);
    _activeMode = name;
    var planeVecs = [new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant)];
    _viewer.setCutPlaneSet('__set_view', planeVecs);
    this.setSection(name);
    return true;
  };
};

function init_SectionMesh() {

  if (SectionMeshClass)
  return;

  SectionMeshClass = function SectionMeshClass(geometry, material, plane) {

    THREE.Mesh.call(this, geometry, material, false);

    this.plane = plane;
    this.planeVec = new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
    this.connectivity = [];
    this.outlines = [];
  };

  SectionMeshClass.prototype = Object.create(THREE.Mesh.prototype);
  SectionMeshClass.prototype.constructor = SectionMeshClass;

  SectionMeshClass.prototype.update = function () {

    this.plane.normal.set(0, 0, 1);
    this.plane.normal.applyQuaternion(this.quaternion);

    var normal = this.plane.normal;
    var d = -1 * this.getWorldPosition().dot(normal);
    this.planeVec.set(normal.x, normal.y, normal.z, d);
    this.plane.constant = d;
  };

}

/***/ }),

/***/ "./node_modules/css-loader/index.js!./extensions/Section/Section.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader!./extensions/Section/Section.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/**\n * Section CSS\n **/\n.sectionPanel {\n    line-height: 14px;\n    text-align: left;\n    z-index: 10;\n}\n\n.section-horizontal-divider\n{\n    height: 1px;\n    border-top: 1px solid rgba(200,200,200,0.8);\n}\n\n.section-submenu-select\n{\n    display: block;\n    position: relative;\n    width: calc(100% - 40px);\n    padding: 10px 20px 0px 20px;\n    opacity: 0.3;\n}\n\n.section-panel:hover .section-submenu-select {\n   opacity: 0.8;\n}\n\n.section-submenu-selectlabel\n{\n    position: relative;\n    display:  inline-block;\n    padding-right:  20px;\n    padding-bottom:  4px;\n}\n\n.section-restart {\n    margin: 10px 20px 15px 20px;\n    padding: 6px 10px 6px 10px;\n    width: calc(100% - 55px);\n    cursor: pointer;\n}\n\n.docking-panel:hover .section-restart {\n    background-color: rgba(255,255,255, .12);\n}\n\n.docking-panel .section-restart:hover {\n    background-color: rgba(166,194,255, 0.7);\n    -webkit-transition: all 0.2s ease;\n    -moz-transition: all 0.2s ease;\n    -ms-transition: all 0.2s ease;\n    -o-transition: all 0.2s ease;\n    transition: all 0.2s ease;\n}\n\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./thirdparty/three.js/TransformControls.js":
/*!**************************************************!*\
  !*** ./thirdparty/three.js/TransformControls.js ***!
  \**************************************************/
/*! exports provided: init_TransformGizmos */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init_TransformGizmos", function() { return init_TransformGizmos; });
/**
 * @author arodic / https://github.com/arodic
 *
 * @author chiena -- Modified for Autodesk LMV web viewer
 */
/*jshint sub:true*/

function init_TransformGizmos() {

  'use strict';

  var GizmoMaterial = function GizmoMaterial(parameters) {

    THREE.MeshBasicMaterial.call(this);

    this.depthTest = false;
    this.depthWrite = false;
    this.side = THREE.FrontSide;
    this.transparent = true;

    this.setValues(parameters);

    this.oldColor = this.color.clone();
    this.oldOpacity = this.opacity;

    this.highlight = function (highlighted) {

      if (highlighted) {

        this.color.setRGB(1, 230 / 255, 3 / 255);
        this.opacity = 1;

      } else {

        this.color.copy(this.oldColor);
        this.opacity = this.oldOpacity;

      }

    };

  };

  GizmoMaterial.prototype = Object.create(THREE.MeshBasicMaterial.prototype);

  var GizmoLineMaterial = function GizmoLineMaterial(parameters) {

    THREE.LineBasicMaterial.call(this);

    this.depthTest = false;
    this.depthWrite = false;
    this.transparent = true;
    this.linewidth = 1;

    this.setValues(parameters);

    this.oldColor = this.color.clone();
    this.oldOpacity = this.opacity;

    this.highlight = function (highlighted) {

      if (highlighted) {

        this.color.setRGB(1, 230 / 255, 3 / 255);
        this.opacity = 1;

      } else {

        this.color.copy(this.oldColor);
        this.opacity = this.oldOpacity;

      }

    };

  };

  GizmoLineMaterial.prototype = Object.create(THREE.LineBasicMaterial.prototype);

  // polyfill
  if (THREE.PolyhedronGeometry === undefined) {
    THREE.PolyhedronGeometry = function (vertices, indices, radius, detail) {

      THREE.Geometry.call(this);

      this.type = 'PolyhedronGeometry';

      this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail };


      radius = radius || 1;
      detail = detail || 0;

      var that = this;

      for (var i = 0, l = vertices.length; i < l; i += 3) {

        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));

      }

      var midpoints = [],p = this.vertices;

      var faces = [];

      for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {

        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];

        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);

      }

      var centroid = new THREE.Vector3();

      for (var i = 0, l = faces.length; i < l; i++) {

        subdivide(faces[i], detail);

      }


      // Handle case when face straddles the seam

      for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {

        var uvs = this.faceVertexUvs[0][i];

        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;

        var max = Math.max(x0, Math.max(x1, x2));
        var min = Math.min(x0, Math.min(x1, x2));

        if (max > 0.9 && min < 0.1) {// 0.9 is somewhat arbitrary

          if (x0 < 0.2) uvs[0].x += 1;
          if (x1 < 0.2) uvs[1].x += 1;
          if (x2 < 0.2) uvs[2].x += 1;

        }

      }


      // Apply radius

      for (var i = 0, l = this.vertices.length; i < l; i++) {

        this.vertices[i].multiplyScalar(radius);

      }


      // Merge vertices

      this.mergeVertices();

      this.computeFaceNormals();

      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);


      // Project vector onto sphere's surface

      function prepare(vector) {

        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;

        // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2(u, 1 - v);

        return vertex;

      }


      // Approximate a curved face with recursively sub-divided triangles.

      function make(v1, v2, v3) {

        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
        that.faces.push(face);

        centroid.copy(v1).add(v2).add(v3).divideScalar(3);

        var azi = azimuth(centroid);

        that.faceVertexUvs[0].push([
        correctUV(v1.uv, v1, azi),
        correctUV(v2.uv, v2, azi),
        correctUV(v3.uv, v3, azi)]);


      }


      // Analytically subdivide a face to the required detail level.

      function subdivide(face, detail) {

        var cols = Math.pow(2, detail);
        var cells = Math.pow(4, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];

        // Construct all of the vertices for this subdivision.

        for (var i = 0; i <= cols; i++) {

          v[i] = [];

          var aj = prepare(a.clone().lerp(c, i / cols));
          var bj = prepare(b.clone().lerp(c, i / cols));
          var rows = cols - i;

          for (var j = 0; j <= rows; j++) {

            if (j == 0 && i == cols) {

              v[i][j] = aj;

            } else {

              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));

            }

          }

        }

        // Construct all of the faces.

        for (var i = 0; i < cols; i++) {

          for (var j = 0; j < 2 * (cols - i) - 1; j++) {

            var k = Math.floor(j / 2);

            if (j % 2 == 0) {

              make(
              v[i][k + 1],
              v[i + 1][k],
              v[i][k]);


            } else {

              make(
              v[i][k + 1],
              v[i + 1][k + 1],
              v[i + 1][k]);


            }

          }

        }

      }


      // Angle around the Y axis, counter-clockwise when looking from above.

      function azimuth(vector) {

        return Math.atan2(vector.z, -vector.x);

      }


      // Angle above the XZ plane.

      function inclination(vector) {

        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));

      }


      // Texture fixing helper. Spheres have some odd behaviours.

      function correctUV(uv, vector, azimuth) {

        if (azimuth < 0 && uv.x === 1) uv = new THREE.Vector2(uv.x - 1, uv.y);
        if (vector.x === 0 && vector.z === 0) uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();

      }

    };

    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
  }

  // polyfill
  if (THREE.OctahedronGeometry === undefined) {
    THREE.OctahedronGeometry = function (radius, detail) {

      this.parameters = {
        radius: radius,
        detail: detail };


      var vertices = [
      1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];


      var indices = [
      0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];


      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);

      this.type = 'OctahedronGeometry';

      this.parameters = {
        radius: radius,
        detail: detail };

    };

    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
  }

  // polyfill
  if (THREE.TorusGeometry === undefined) {
    THREE.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {

      THREE.Geometry.call(this);

      this.type = 'TorusGeometry';

      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc };


      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 8;
      tubularSegments = tubularSegments || 6;
      arc = arc || Math.PI * 2;

      var center = new THREE.Vector3(),uvs = [],normals = [];

      for (var j = 0; j <= radialSegments; j++) {

        for (var i = 0; i <= tubularSegments; i++) {

          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;

          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);

          var vertex = new THREE.Vector3();
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);

          this.vertices.push(vertex);

          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
          normals.push(vertex.clone().sub(center).normalize());

        }

      }

      for (var j = 1; j <= radialSegments; j++) {

        for (var i = 1; i <= tubularSegments; i++) {

          var a = (tubularSegments + 1) * j + i - 1;
          var b = (tubularSegments + 1) * (j - 1) + i - 1;
          var c = (tubularSegments + 1) * (j - 1) + i;
          var d = (tubularSegments + 1) * j + i;

          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);

          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);

        }

      }

      this.computeFaceNormals();

    };

    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
  }

  var createCircleGeometry = function createCircleGeometry(radius, facing, arc) {

    var geometry = new THREE.Geometry();
    arc = arc ? arc : 1;
    for (var i = 0; i <= 64 * arc; ++i) {
      if (facing == 'x') geometry.vertices.push(new THREE.Vector3(0, Math.cos(i / 32 * Math.PI), Math.sin(i / 32 * Math.PI)).multiplyScalar(radius));
      if (facing == 'y') geometry.vertices.push(new THREE.Vector3(Math.cos(i / 32 * Math.PI), 0, Math.sin(i / 32 * Math.PI)).multiplyScalar(radius));
      if (facing == 'z') geometry.vertices.push(new THREE.Vector3(Math.sin(i / 32 * Math.PI), Math.cos(i / 32 * Math.PI), 0).multiplyScalar(radius));
    }

    return geometry;
  };

  var createArrowGeometry = function createArrowGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {

    var arrowGeometry = new THREE.Geometry();
    var mesh = new THREE.Mesh(new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded));
    mesh.position.y = 0.5;
    mesh.updateMatrix();

    arrowGeometry.merge(mesh.geometry, mesh.matrix);

    return arrowGeometry;
  };

  var createLineGeometry = function createLineGeometry(axis) {

    var lineGeometry = new THREE.Geometry();
    if (axis === 'X')
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0));else
    if (axis === 'Y')
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));else
    if (axis === 'Z')
    lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));

    return lineGeometry;
  };

  THREE.TransformGizmo = function () {

    var scope = this;
    var showPickers = false; //debug
    var showActivePlane = false; //debug

    this.init = function () {

      THREE.Object3D.call(this);

      this.handles = new THREE.Object3D();
      this.pickers = new THREE.Object3D();
      this.planes = new THREE.Object3D();
      this.highlights = new THREE.Object3D();
      this.hemiPicker = new THREE.Object3D();
      this.subPickers = new THREE.Object3D();

      this.add(this.handles);
      this.add(this.pickers);
      this.add(this.planes);
      this.add(this.highlights);
      this.add(this.hemiPicker);
      this.add(this.subPickers);

      //// PLANES

      var planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);
      var planeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });
      planeMaterial.side = THREE.DoubleSide;

      var planes = {
        "XY": new THREE.Mesh(planeGeometry, planeMaterial),
        "YZ": new THREE.Mesh(planeGeometry, planeMaterial),
        "XZ": new THREE.Mesh(planeGeometry, planeMaterial),
        "XYZE": new THREE.Mesh(planeGeometry, planeMaterial) };


      this.activePlane = planes["XYZE"];

      planes["YZ"].rotation.set(0, Math.PI / 2, 0);
      planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

      for (var i in planes) {
        planes[i].name = i;
        this.planes.add(planes[i]);
        this.planes[i] = planes[i];
        planes[i].visible = false;
      }

      this.setupGizmos();
      this.activeMode = "";

      // reset Transformations

      this.traverse(function (child) {
        if (child instanceof THREE.Mesh) {
          child.updateMatrix();

          var tempGeometry = new THREE.Geometry();
          if (child.geometry instanceof THREE.BufferGeometry) {
            child.geometry = new THREE.Geometry().fromBufferGeometry(child.geometry);
          }
          tempGeometry.merge(child.geometry, child.matrix);

          child.geometry = tempGeometry;
          child.position.set(0, 0, 0);
          child.rotation.set(0, 0, 0);
          child.scale.set(1, 1, 1);
        }
      });

    };

    this.hide = function () {
      this.traverse(function (child) {
        child.visible = false;
      });
    };

    this.show = function () {
      this.traverse(function (child) {
        child.visible = true;
        if (child.parent == scope.pickers || child.parent == scope.hemiPicker) child.visible = showPickers;
        if (child.parent == scope.planes) child.visible = false;
      });
      this.activePlane.visible = showActivePlane;
    };

    this.highlight = function (axis) {
      this.traverse(function (child) {
        if (child.material && child.material.highlight) {
          if (child.name == axis) {
            child.material.highlight(true);
          } else {
            child.material.highlight(false);
          }
        }
      });
    };

    this.setupGizmos = function () {

      var addGizmos = function addGizmos(gizmoMap, parent) {

        for (var name in gizmoMap) {

          for (var i = gizmoMap[name].length; i--;) {

            var object = gizmoMap[name][i][0];
            var position = gizmoMap[name][i][1];
            var rotation = gizmoMap[name][i][2];
            var visble = gizmoMap[name][i][3];

            object.name = name;

            if (position) object.position.set(position[0], position[1], position[2]);
            if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);
            if (visble) object.visble = visble;

            parent.add(object);

          }

        }

      };

      this.setHandlePickerGizmos();

      addGizmos(this.handleGizmos, this.handles);
      addGizmos(this.pickerGizmos, this.pickers);
      addGizmos(this.highlightGizmos, this.highlights);
      addGizmos(this.hemiPickerGizmos, this.hemiPicker);
      addGizmos(this.subPickerGizmos, this.subPickers);

      this.hide();
      this.show();

    };

  };

  THREE.TransformGizmo.prototype = Object.create(THREE.Object3D.prototype);

  THREE.TransformGizmo.prototype.update = function (rotation, eye) {

    var vec1 = new THREE.Vector3(0, 0, 0);
    var vec2 = new THREE.Vector3(0, 1, 0);
    var lookAtMatrix = new THREE.Matrix4();

    this.traverse(function (child) {
      if (child.name) {
        if (child.name.search("E") != -1) {
          child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
        } else if (child.name.search("X") != -1 || child.name.search("Y") != -1 || child.name.search("Z") != -1) {
          child.quaternion.setFromEuler(rotation);
        }
      }
    });

  };

  THREE.TransformGizmoTranslate = function () {

    THREE.TransformGizmo.call(this);

    this.setHandlePickerGizmos = function () {

      var arrowGeometry = createArrowGeometry(0, 0.05, 0.2, 12, 1, false);
      var lineXGeometry = createLineGeometry('X');
      var lineYGeometry = createLineGeometry('Y');
      var lineZGeometry = createLineGeometry('Z');

      this.handleGizmos = {
        X: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xf12c2c })), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xf12c2c }))]],

        Y: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0bb80b })), [0, 0.5, 0]],
        [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x0bb80b }))]],

        Z: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x2c2cf1 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x2c2cf1 }))]],

        XYZ: [
        [new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],

        XY: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],

        YZ: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],

        XZ: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] };



      this.pickerGizmos = {
        X: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

        Y: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0.6, 0]]],

        Z: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

        XYZ: [
        [new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]],

        XY: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.2, 0.2, 0]]],

        YZ: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],

        XZ: [
        [new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]] };



      this.hemiPickerGizmos = {
        XYZ: [
        [new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new GizmoMaterial({ color: 0x0000ff })), [0.5, 0.5, 0.5], null, false]] };



    };

    this.setActivePlane = function (axis, eye) {

      var tempMatrix = new THREE.Matrix4();
      eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

      if (axis == "X") {
        this.activePlane = this.planes["XY"];
        if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
      }

      if (axis == "Y") {
        this.activePlane = this.planes["XY"];
        if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
      }

      if (axis == "Z") {
        this.activePlane = this.planes["XZ"];
        if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
      }

      if (axis == "XYZ") this.activePlane = this.planes["XYZE"];

      if (axis == "XY") this.activePlane = this.planes["XY"];

      if (axis == "YZ") this.activePlane = this.planes["YZ"];

      if (axis == "XZ") this.activePlane = this.planes["XZ"];

      this.hide();
      this.show();

    };

    this.init();

  };

  THREE.TransformGizmoTranslate.prototype = Object.create(THREE.TransformGizmo.prototype);

  THREE.TransformGizmoRotate = function () {

    THREE.TransformGizmo.call(this);

    this.setHandlePickerGizmos = function () {

      this.handleGizmos = {
        RX: [
        [new THREE.Line(createCircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],

        RY: [
        [new THREE.Line(createCircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],

        RZ: [
        [new THREE.Line(createCircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],

        RE: [
        [new THREE.Line(createCircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0x00ffff }))]],

        RXYZE: [
        [new THREE.Line(createCircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0xff00ff }))]] };



      this.pickerGizmos = {
        RX: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],

        RY: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0, 0], [Math.PI / 2, 0, 0]]],

        RZ: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0], [0, 0, -Math.PI / 2]]],

        RE: [
        [new THREE.Mesh(new THREE.TorusGeometry(1.25, 0.12, 2, 24), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 }))]],

        RXYZE: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 2, 24), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 }))]] };



    };

    this.setActivePlane = function (axis) {

      if (axis == "RE") this.activePlane = this.planes["XYZE"];

      if (axis == "RX") this.activePlane = this.planes["YZ"];

      if (axis == "RY") this.activePlane = this.planes["XZ"];

      if (axis == "RZ") this.activePlane = this.planes["XY"];

      this.hide();
      this.show();

    };

    this.update = function (rotation, eye2) {

      THREE.TransformGizmo.prototype.update.apply(this, arguments);

      var tempMatrix = new THREE.Matrix4();
      var worldRotation = new THREE.Euler(0, 0, 1);
      var tempQuaternion = new THREE.Quaternion();
      var unitX = new THREE.Vector3(1, 0, 0);
      var unitY = new THREE.Vector3(0, 1, 0);
      var unitZ = new THREE.Vector3(0, 0, 1);
      var quaternionX = new THREE.Quaternion();
      var quaternionY = new THREE.Quaternion();
      var quaternionZ = new THREE.Quaternion();
      var eye = eye2.clone();

      worldRotation.copy(this.planes["XY"].rotation);
      tempQuaternion.setFromEuler(worldRotation);

      tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
      eye.applyMatrix4(tempMatrix);

      this.traverse(function (child) {

        tempQuaternion.setFromEuler(worldRotation);

        if (child.name == "RX") {
          quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
          child.quaternion.copy(tempQuaternion);
        }

        if (child.name == "RY") {
          quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
          child.quaternion.copy(tempQuaternion);
        }

        if (child.name == "RZ") {
          quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
          child.quaternion.copy(tempQuaternion);
        }

      });

    };

    this.init();

  };

  THREE.TransformGizmoRotate.prototype = Object.create(THREE.TransformGizmo.prototype);

  THREE.TransformGizmoTranslateRotate = function () {

    THREE.TransformGizmo.call(this);

    var scope = this;

    this.setHandlePickerGizmos = function () {

      var arrowGeometry = createArrowGeometry(0, 0.05, 0.2, 12, 1, false);
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(0, 0, -0.1), new THREE.Vector3(0, 0, 0.1), new THREE.Vector3(-0.1, 0, 0), new THREE.Vector3(0.1, 0, 0));
      var theta = 0.15;

      this.handleGizmos = {
        Z: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xffffff })), [0, 0, 0.25], [Math.PI / 2, 0, 0]],
        [new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.6, 4, 1, false), new GizmoMaterial({ color: 0xffffff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],

        RX: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.015, 12, 60, theta * 2 * Math.PI), new GizmoMaterial({ color: 0xff0000 })), [0, 0, 0], [theta * Math.PI, -Math.PI / 2, 0]],
        [new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.015, 60, 1, false), new GizmoMaterial({ color: 0xff0000 })), [0, 0, 1], [Math.PI / 2, 0, 0]]],

        RY: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.015, 12, 60, theta * 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0], [Math.PI / 2, 0, (0.5 - theta) * Math.PI]],
        [new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.01, 60, 1, false), new GizmoMaterial({ color: 0x0000ff })), [0, 0, 1]]] };



      this.pickerGizmos = {
        Z: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.65, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],

        RX: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, theta * 2 * Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0, 0, 0], [theta * Math.PI, -Math.PI / 2, 0]]],

        RY: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.12, 4, 12, theta * 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0], [Math.PI / 2, 0, (0.5 - theta) * Math.PI]]] };



      this.subPickerGizmos = {
        Z: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.65, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.5], [Math.PI / 2, 0, 0]]] };



      this.highlightGizmos = {
        Z: [],

        RX: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 12, 60, 2 * Math.PI), new GizmoMaterial({ color: 0xff0000, opacity: 1 })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2], false]],

        RY: [
        [new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 12, 60, 2 * Math.PI), new GizmoMaterial({ color: 0x0000ff, opacity: 1 })), [0, 0, 0], [Math.PI / 2, 0, 0], false]] };



      this.hemiPickerGizmos = {
        XYZ: [
        [new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 8, 0, Math.PI), new GizmoMaterial({ color: 0x0000ff })), null, null, false]] };



    };

    this.setActivePlane = function (axis, eye) {

      if (this.activeMode == "translate") {

        var tempMatrix = new THREE.Matrix4();
        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

        if (axis == "X") {
          this.activePlane = this.planes["XY"];
          if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
        }

        if (axis == "Y") {
          this.activePlane = this.planes["XY"];
          if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
        }

        if (axis == "Z") {
          this.activePlane = this.planes["XZ"];
          if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
        }

      } else if (this.activeMode == "rotate") {

        if (axis == "RX") this.activePlane = this.planes["YZ"];

        if (axis == "RY") this.activePlane = this.planes["XZ"];

        if (axis == "RZ") this.activePlane = this.planes["XY"];

      }

      this.hide();
      this.show();

    };

    this.update = function (rotation, eye2) {

      if (this.activeMode == "translate") {

        THREE.TransformGizmo.prototype.update.apply(this, arguments);

      } else if (this.activeMode == "rotate") {

        THREE.TransformGizmo.prototype.update.apply(this, arguments);

        var tempMatrix = new THREE.Matrix4();
        var worldRotation = new THREE.Euler(0, 0, 1);
        var tempQuaternion = new THREE.Quaternion();
        var unitX = new THREE.Vector3(1, 0, 0);
        var unitY = new THREE.Vector3(0, 1, 0);
        var unitZ = new THREE.Vector3(0, 0, 1);
        var quaternionX = new THREE.Quaternion();
        var quaternionY = new THREE.Quaternion();
        var quaternionZ = new THREE.Quaternion();
        var eye = eye2.clone();

        worldRotation.copy(this.planes["XY"].rotation);
        tempQuaternion.setFromEuler(worldRotation);

        tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
        eye.applyMatrix4(tempMatrix);

        this.traverse(function (child) {

          tempQuaternion.setFromEuler(worldRotation);

          if (child.name == "RX") {
            quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
            child.quaternion.copy(tempQuaternion);
          }

          if (child.name == "RY") {
            quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
            child.quaternion.copy(tempQuaternion);
          }

          if (child.name == "RZ") {
            quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
            tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
            child.quaternion.copy(tempQuaternion);
          }

        });

      }

    };

    this.show = function () {
      this.traverse(function (child) {
        if (scope.parent == null || scope.parent.useAllPickers || child.parent != scope.handles) child.visible = true;
        if (child.material) child.material.opacity = child.material.oldOpacity;
        if (child.parent == scope.pickers || child.parent == scope.hemiPicker || child.parent == scope.subPickers) child.visible = false;
        if (child.parent == scope.planes || child.parent == scope.highlights) child.visible = false;
      });
      this.activePlane.visible = false;
    };

    this.highlight = function (axis) {
      this.traverse(function (child) {
        if (child.material && child.material.highlight) {
          if (child.name == axis) {
            if (child.parent == scope.highlights || child.parent == scope.handles) child.visible = true;
            child.material.highlight(true);
          } else {
            child.material.highlight(false);
            child.material.opacity = 0.1;
          }
        }
      });
    };

    this.init();

  };

  THREE.TransformGizmoTranslateRotate.prototype = Object.create(THREE.TransformGizmo.prototype);

  THREE.TransformGizmoScale = function () {

    THREE.TransformGizmo.call(this);

    this.setHandlePickerGizmos = function () {

      var arrowGeometry = createArrowGeometry(0.125, 0.125, 0.125);
      var lineXGeometry = createLineGeometry('X');
      var lineYGeometry = createLineGeometry('Y');
      var lineZGeometry = createLineGeometry('Z');

      this.handleGizmos = {
        X: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],

        Y: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]],
        [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],

        Z: [
        [new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],

        XYZ: [
        [new THREE.Mesh(new THREE.BoxGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]] };



      this.pickerGizmos = {
        X: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0xff0000, opacity: 0.25 })), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

        Y: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x00ff00, opacity: 0.25 })), [0, 0.6, 0]]],

        Z: [
        [new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 1, 4, 1, false), new GizmoMaterial({ color: 0x0000ff, opacity: 0.25 })), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

        XYZ: [
        [new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]] };



    };

    this.setActivePlane = function (axis, eye) {

      var tempMatrix = new THREE.Matrix4();
      eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

      if (axis == "X") {
        this.activePlane = this.planes["XY"];
        if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
      }

      if (axis == "Y") {
        this.activePlane = this.planes["XY"];
        if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
      }

      if (axis == "Z") {
        this.activePlane = this.planes["XZ"];
        if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
      }

      if (axis == "XYZ") this.activePlane = this.planes["XYZE"];

      this.hide();
      this.show();

    };

    this.init();

  };

  THREE.TransformGizmoScale.prototype = Object.create(THREE.TransformGizmo.prototype);

  THREE.TransformControls = function (camera, domElement, mode) {

    // TODO: Make non-uniform scale and rotate play nice in hierarchies
    // TODO: ADD RXYZ contol

    THREE.Object3D.call(this);

    domElement = domElement !== undefined ? domElement : document;

    this.gizmo = {};
    switch (mode) {
      case "translate":
        this.gizmo[mode] = new THREE.TransformGizmoTranslate();
        break;
      case "rotate":
        this.gizmo[mode] = new THREE.TransformGizmoRotate();
        break;
      case "transrotate":
        this.gizmo[mode] = new THREE.TransformGizmoTranslateRotate();
        break;
      case "scale":
        this.gizmo[mode] = new THREE.TransformGizmoScale();
        break;}


    this.add(this.gizmo[mode]);
    this.gizmo[mode].hide();

    this.object = undefined;
    this.snap = null;
    this.snapDelta = 0;
    this.space = "world";
    this.size = 1;
    this.axis = null;
    this.useAllPickers = true;

    this.unitX = new THREE.Vector3(1, 0, 0);
    this.unitY = new THREE.Vector3(0, 1, 0);
    this.unitZ = new THREE.Vector3(0, 0, 1);
    this.normal = new THREE.Vector3(0, 0, 1);

    if (mode === "transrotate") {
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));
      var material = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2, depthTest: false });
      this.startLine = new THREE.Line(geometry, material);
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({ color: 0xffe603, linewidth: 2, depthTest: false });
      geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));
      this.endLine = new THREE.Line(geometry, material);
      var geometry = new THREE.Geometry();
      var material = new THREE.LineDashedMaterial({ color: 0x000000, linewidth: 1, depthTest: false });
      geometry.vertices.push(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0));
      this.centerLine = new THREE.Line(geometry, material);

      var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/centerMarker_X.png"));
      map.magFilter = map.minFilter = THREE.NearestFilter;
      var geometry = new THREE.CircleGeometry(0.1, 32);
      var material = new THREE.MeshBasicMaterial({ opacity: 1, side: THREE.DoubleSide, transparent: true, map: map });
      this.centerMark = new THREE.Mesh(geometry, material);
      this.centerMark.rotation.set(Math.PI / 2, 0, 0);

      this.ticks = {};
      var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/cardinalPoint.png"));
      map.magFilter = map.minFilter = THREE.NearestFilter;
      var material = new THREE.MeshBasicMaterial({ depthTest: false, opacity: 1, transparent: true, side: THREE.DoubleSide, map: map });
      var w = 0.12,h = 0.25,d = 1.15;

      this.ticks["RX"] = new THREE.Object3D();
      var geometry = new THREE.PlaneBufferGeometry(w, h);
      var mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0, 0, -d - h / 2);
      mesh.rotation.set(Math.PI / 2, Math.PI / 2, 0);
      this.ticks["RX"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(0, d + h / 2, 0);
      mesh.rotation.set(0, Math.PI / 2, 0);
      this.ticks["RX"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(0, 0, d + h / 2);
      mesh.rotation.set(0, Math.PI / 2, Math.PI / 2);
      this.ticks["RX"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(0, -d - h / 2, 0);
      mesh.rotation.set(0, Math.PI / 2, 0);
      this.ticks["RX"].add(mesh);

      this.ticks["RY"] = new THREE.Object3D();
      mesh = mesh.clone();
      mesh.position.set(0, 0, -d - h / 2);
      mesh.rotation.set(Math.PI / 2, 0, 0);
      this.ticks["RY"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(-d - h / 2, 0, 0);
      mesh.rotation.set(Math.PI / 2, 0, Math.PI / 2);
      this.ticks["RY"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(0, 0, d + h / 2);
      mesh.rotation.set(Math.PI / 2, 0, 0);
      this.ticks["RY"].add(mesh);

      mesh = mesh.clone();
      mesh.position.set(d + h / 2, 0, 0);
      mesh.rotation.set(Math.PI / 2, 0, Math.PI / 2);
      this.ticks["RY"].add(mesh);
    }

    var scope = this;

    var _dragging = false;
    var _mode = mode;
    var _plane = "XY";

    var changeEvent = { type: "change" };
    var mouseDownEvent = { type: "mouseDown" };
    var mouseUpEvent = { type: "mouseUp", mode: _mode };
    var objectChangeEvent = { type: "objectChange" };

    var ray = new THREE.Raycaster();
    var pointerVector = new THREE.Vector3();
    var pointerDir = new THREE.Vector3();

    var point = new THREE.Vector3();
    var offset = new THREE.Vector3();

    var rotation = new THREE.Vector3();
    var offsetRotation = new THREE.Vector3();
    var scale = 1;
    this.clientScale = 1;

    var lookAtMatrix = new THREE.Matrix4();
    var eye = new THREE.Vector3();

    var tempMatrix = new THREE.Matrix4();
    var tempVector = new THREE.Vector3();
    var tempQuaternion = new THREE.Quaternion();
    var projX = new THREE.Vector3();
    var projY = new THREE.Vector3();
    var projZ = new THREE.Vector3();

    var quaternionXYZ = new THREE.Quaternion();
    var quaternionX = new THREE.Quaternion();
    var quaternionY = new THREE.Quaternion();
    var quaternionZ = new THREE.Quaternion();
    var quaternionE = new THREE.Quaternion();

    var oldPosition = new THREE.Vector3();
    var oldScale = new THREE.Vector3();
    var oldRotationMatrix = new THREE.Matrix4();

    var parentRotationMatrix = new THREE.Matrix4();
    var parentScale = new THREE.Vector3();

    var worldPosition = new THREE.Vector3();
    var worldRotation = new THREE.Euler();
    var worldRotationMatrix = new THREE.Matrix4();
    var camPosition = new THREE.Vector3();
    var camRotation = new THREE.Euler();

    this.attach = function (object) {

      scope.object = object;

      this.gizmo[_mode].show();

      scope.update();

      scope.updateUnitVectors();

    };

    this.detach = function (object) {

      scope.object = undefined;
      this.axis = null;

      this.gizmo[_mode].hide();

    };

    this.setMode = function (mode) {

      _mode = mode ? mode : _mode;

      if (_mode == "scale") scope.space = "local";

      this.gizmo[_mode].show();

      this.update();
      scope.dispatchEvent(changeEvent);

    };

    this.getPicker = function () {

      return scope.gizmo[_mode].hemiPicker.children;

    };

    this.setPosition = function (position) {

      this.object.position.copy(position);
      this.update();

    };

    this.setNormal = function (normal) {

      tempQuaternion.setFromUnitVectors(this.normal, normal);
      this.unitX.applyQuaternion(tempQuaternion);
      this.unitY.applyQuaternion(tempQuaternion);
      this.unitZ.applyQuaternion(tempQuaternion);
      this.normal.copy(normal);
      if (this.object) {
        this.object.quaternion.multiply(tempQuaternion);
      }
      this.update();
    };

    this.setSnap = function (snap, delta) {

      scope.snap = snap;
      scope.snapDelta = delta;

    };

    this.setSize = function (size) {

      scope.size = size;
      this.update();
      scope.dispatchEvent(changeEvent);

    };

    this.setSpace = function (space) {

      scope.space = space;
      this.update();
      scope.dispatchEvent(changeEvent);

    };

    this.update = function (highlight) {

      if (scope.object === undefined) return;

      scope.object.updateMatrixWorld();
      worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
      worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));

      camera.updateMatrixWorld();
      camPosition.setFromMatrixPosition(camera.matrixWorld);
      //camRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );

      this.position.copy(worldPosition);

      this.quaternion.setFromEuler(worldRotation);

      this.normal.set(0, 0, 1);
      this.normal.applyEuler(worldRotation);

      // keep same screen height (100px)
      var height;
      if (camera.isPerspective) {
        var dist = worldPosition.distanceTo(camPosition);
        height = 2 * Math.tan(camera.fov * Math.PI / 360) * dist;
      } else {
        // orthographic, so the world height is simply top minus bottom
        height = camera.top - camera.bottom;
      }
      var rect = domElement.getBoundingClientRect();
      // multiply 100 pixels by world height for the window, divide by window height in pixels,
      // to get world height equivalent to 100 pixels.
      scale = this.clientScale * 100 * height / rect.height;
      this.scale.set(scale, scale, scale);

      // Set the gizmo position with the specified offset.
      if (this.gizmoOffset) {
        this.position.add(this.gizmoOffset);
      }
      this.updateMatrixWorld();
      //eye.copy( camPosition ).sub( worldPosition ).normalize();

      //if ( scope.space == "local" )
      //    this.gizmo[_mode].update( worldRotation, eye );
      //else if ( scope.space == "world" )
      //    this.gizmo[_mode].update( new THREE.Euler(), eye );

      if (highlight)
      this.gizmo[_mode].highlight(scope.axis);

    };

    this.setGizmoOffset = function (vec) {
      // Reset the gizmo if no vector passed in.
      this.gizmoOffset = !vec ? new THREE.Vector3(0, 0, 0) : vec;
      this.update();
    };

    this.updateUnitVectors = function () {

      this.unitX.set(1, 0, 0);
      this.unitY.set(0, 1, 0);
      this.unitZ.set(0, 0, 1);
      this.unitX.applyEuler(worldRotation);
      this.unitY.applyEuler(worldRotation);
      this.unitZ.applyEuler(worldRotation);

    };

    this.showRotationGizmos = function (set) {

      var handles = this.gizmo[_mode].handles.children;
      for (var i = 0; i < handles.length; i++) {
        var child = handles[i];
        child.visible = true;
        if (child.name.search("R") !== -1) child.visible = set;
      }
      this.useAllPickers = set;

    };

    this.highlight = function () {

      this.gizmo[_mode].highlight(this.axis || "Z");

    };

    this.onPointerHover = function (event) {

      if (scope.object === undefined || _dragging === true) return false;

      var pointer = event;

      var intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);

      var axis = null;
      var mode = "";

      if (intersect) {

        axis = intersect.object.name;
        mode = axis.search("R") != -1 ? "rotate" : "translate";

      }

      if (scope.axis !== axis) {

        scope.axis = axis;
        scope.gizmo[_mode].activeMode = mode;
        scope.update(true);
        scope.dispatchEvent(changeEvent);

      }

      if (scope.axis === null) {

        scope.gizmo[_mode].show();

      }

      return intersect ? true : false;

    };

    this.onPointerDown = function (event) {

      if (scope.object === undefined || _dragging === true) return false;

      var pointer = event;

      if (event.pointerType === 'touch') {

        var intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);

        var axis = null;
        var mode = "";

        if (intersect) {

          axis = intersect.object.name;
          mode = axis.search("R") != -1 ? "rotate" : "translate";

        }

        if (scope.axis !== axis) {

          scope.axis = axis;
          scope.gizmo[_mode].activeMode = mode;
        }
      }

      var intersect = null;

      if (pointer.button === 0 || pointer.button === -1 || pointer.button === undefined) {

        intersect = intersectObjects(pointer, scope.useAllPickers ? scope.gizmo[_mode].pickers.children : scope.gizmo[_mode].subPickers.children);

        if (intersect) {

          scope.dispatchEvent(mouseDownEvent);

          scope.axis = intersect.object.name;

          scope.update();

          eye.copy(camera.position).sub(worldPosition).normalize();

          scope.gizmo[_mode].setActivePlane(scope.axis, eye);

          var planeIntersect = intersectObjects(pointer, [scope.gizmo[_mode].activePlane]);

          if (planeIntersect)
          offset.copy(planeIntersect.point);

          oldPosition.copy(scope.object.position);
          oldScale.copy(scope.object.scale);

          oldRotationMatrix.extractRotation(scope.object.matrix);
          worldRotationMatrix.extractRotation(scope.object.matrixWorld);

          if (scope.object.parent) {
            parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
            parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));
          } else {
            parentRotationMatrix.extractRotation(scope.object.matrixWorld);
            parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.matrixWorld));
          }

          // show rotation start line and ticks
          if (_mode === "transrotate" && scope.gizmo[_mode].activeMode === "rotate") {
            scope.startLine.geometry.vertices[0].set(0, 0, 0).applyMatrix4(scope.matrixWorld);
            scope.startLine.geometry.vertices[1].set(0, 0, 1).applyMatrix4(scope.matrixWorld);
            scope.startLine.geometry.verticesNeedUpdate = true;
            scope.parent.add(scope.startLine);

            var pos = scope.object.geometry.getAttribute('position');
            var pt1 = new THREE.Vector3().fromAttribute(pos, 0).applyMatrix4(scope.object.matrixWorld);
            var pt2 = new THREE.Vector3().fromAttribute(pos, 1).applyMatrix4(scope.object.matrixWorld);
            var pt3 = new THREE.Vector3().fromAttribute(pos, 2).applyMatrix4(scope.object.matrixWorld);
            var pt4 = new THREE.Vector3().fromAttribute(pos, 3).applyMatrix4(scope.object.matrixWorld);
            if (scope.axis === "RX") {
              pt1.lerp(pt3, 0.5);
              pt2.lerp(pt4, 0.5);
              var dist = pt1.distanceTo(pt2);
              scope.centerLine.material.dashSize = dist / 15;
              scope.centerLine.material.gapSize = dist / 30;
              scope.centerLine.geometry.vertices[0].copy(pt1);
              scope.centerLine.geometry.vertices[1].copy(pt2);
            } else {
              pt1.lerp(pt2, 0.5);
              pt3.lerp(pt4, 0.5);
              var dist = pt1.distanceTo(pt3);
              scope.centerLine.material.dashSize = dist / 15;
              scope.centerLine.material.gapSize = dist / 30;
              scope.centerLine.geometry.vertices[0].copy(pt1);
              scope.centerLine.geometry.vertices[1].copy(pt3);
            }
            scope.centerLine.geometry.computeLineDistances();
            scope.centerLine.geometry.verticesNeedUpdate = true;
            scope.parent.add(scope.centerLine);

            scope.ticks[scope.axis].position.copy(scope.position);
            scope.ticks[scope.axis].quaternion.copy(scope.quaternion);
            scope.ticks[scope.axis].scale.copy(scope.scale);
            scope.parent.add(scope.ticks[scope.axis]);
          }

        }

      }

      _dragging = true;

      return intersect ? true : false;

    };

    this.onPointerMove = function (event) {

      if (scope.object === undefined || scope.axis === null || _dragging === false) return false;

      var pointer = event;

      var planeIntersect = intersectObjects(pointer, [scope.gizmo[_mode].activePlane]);

      if (planeIntersect)
      point.copy(planeIntersect.point);

      var mode = scope.gizmo[_mode].activeMode;
      if (mode == "translate") {

        point.sub(offset);
        point.multiply(parentScale);

        if (scope.space == "local") {

          point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

          projX.copy(this.unitX);
          projY.copy(this.unitY);
          projZ.copy(this.unitZ);
          tempVector.set(0, 0, 0);
          if (scope.axis.search("X") != -1) {
            projX.multiplyScalar(point.dot(this.unitX));
            tempVector.add(projX);
          }
          if (scope.axis.search("Y") != -1) {
            projY.multiplyScalar(point.dot(this.unitY));
            tempVector.add(projY);
          }
          if (scope.axis.search("Z") != -1) {
            projZ.multiplyScalar(point.dot(this.unitZ));
            tempVector.add(projZ);
          }
          point.copy(tempVector);

          point.applyMatrix4(oldRotationMatrix);

          scope.object.position.copy(oldPosition);
          scope.object.position.add(point);

        }

        if (scope.space == "world" || scope.axis.search("XYZ") != -1) {

          projX.copy(this.unitX);
          projY.copy(this.unitY);
          projZ.copy(this.unitZ);
          tempVector.set(0, 0, 0);
          if (scope.axis.search("X") != -1) {
            projX.multiplyScalar(point.dot(this.unitX));
            tempVector.add(projX);
          }
          if (scope.axis.search("Y") != -1) {
            projY.multiplyScalar(point.dot(this.unitY));
            tempVector.add(projY);
          }
          if (scope.axis.search("Z") != -1) {
            projZ.multiplyScalar(point.dot(this.unitZ));
            tempVector.add(projZ);
          }
          point.copy(tempVector);

          point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));

          scope.object.position.copy(oldPosition);
          scope.object.position.add(point);

        }

      } else if (mode == "scale") {

        point.sub(offset);
        point.multiply(parentScale);

        if (scope.space == "local") {

          if (scope.axis == "XYZ") {

            scale = 1 + point.y / 50;

            scope.object.scale.x = oldScale.x * scale;
            scope.object.scale.y = oldScale.y * scale;
            scope.object.scale.z = oldScale.z * scale;

          } else {

            point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

            if (scope.axis == "X") scope.object.scale.x = oldScale.x * (1 + point.x / 50);
            if (scope.axis == "Y") scope.object.scale.y = oldScale.y * (1 + point.y / 50);
            if (scope.axis == "Z") scope.object.scale.z = oldScale.z * (1 + point.z / 50);

          }

        }

      } else if (mode == "rotate") {

        point.sub(worldPosition);
        point.multiply(parentScale);
        tempVector.copy(offset).sub(worldPosition);
        tempVector.multiply(parentScale);

        if (scope.axis == "RE") {

          point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
          tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));

          rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
          offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

          var rotz = rotation.z - offsetRotation.z;
          if (scope.snap !== null) {
            var rotsnap = Math.round(rotz / scope.snap) * scope.snap;
            if (Math.abs(rotsnap - rotz) < scope.snapDelta) {
              rotz = rotsnap;
            }
          }
          quaternionE.setFromAxisAngle(eye, rotz);
          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

          scope.object.quaternion.copy(tempQuaternion);

        } else if (scope.axis == "RXYZE") {

          var tempAxis = point.clone().cross(tempVector).normalize(); // rotation axis

          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

          var rot = -point.clone().angleTo(tempVector);
          if (scope.snap !== null) {
            var rotsnap = Math.round(rot / scope.snap) * scope.snap;
            if (Math.abs(rotsnap - rot) < scope.snapDelta) {
              rot = rotsnap;
            }
          }
          quaternionX.setFromAxisAngle(tempAxis, rot);
          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

          scope.object.quaternion.copy(tempQuaternion);

        } else if (scope.space == "local") {

          point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

          tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

          var projx = point.dot(this.unitX),projy = point.dot(this.unitY),projz = point.dot(this.unitZ);
          var tempx = tempVector.dot(this.unitX),tempy = tempVector.dot(this.unitY),tempz = tempVector.dot(this.unitZ);
          rotation.set(Math.atan2(projz, projy), Math.atan2(projx, projz), Math.atan2(projy, projx));
          offsetRotation.set(Math.atan2(tempz, tempy), Math.atan2(tempx, tempz), Math.atan2(tempy, tempx));

          var rotx = rotation.x - offsetRotation.x;
          var roty = rotation.y - offsetRotation.y;
          var rotz = rotation.z - offsetRotation.z;
          if (scope.snap !== null) {
            if (scope.axis.search("X") != -1) {
              var rotsnap = Math.round(rotx / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - rotx) < scope.snapDelta) {
                rotx = rotsnap;
              }
            }
            if (scope.axis.search("Y") != -1) {
              var rotsnap = Math.round(roty / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - roty) < scope.snapDelta) {
                roty = rotsnap;
              }
            }
            if (scope.axis.search("Z") != -1) {
              var rotsnap = Math.round(rotz / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - rotz) < scope.snapDelta) {
                rotz = rotsnap;
              }
            }
          }
          quaternionX.setFromAxisAngle(this.unitX, rotx);
          quaternionY.setFromAxisAngle(this.unitY, roty);
          quaternionZ.setFromAxisAngle(this.unitZ, rotz);
          quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);

          if (scope.axis == "RX") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
          if (scope.axis == "RY") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
          if (scope.axis == "RZ") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);

          scope.object.quaternion.copy(quaternionXYZ);

        } else if (scope.space == "world") {

          var projx = point.dot(this.unitX),projy = point.dot(this.unitY),projz = point.dot(this.unitZ);
          var tempx = tempVector.dot(this.unitX),tempy = tempVector.dot(this.unitY),tempz = tempVector.dot(this.unitZ);
          rotation.set(Math.atan2(projz, projy), Math.atan2(projx, projz), Math.atan2(projy, projx));
          offsetRotation.set(Math.atan2(tempz, tempy), Math.atan2(tempx, tempz), Math.atan2(tempy, tempx));

          tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

          var rotx = rotation.x - offsetRotation.x;
          var roty = rotation.y - offsetRotation.y;
          var rotz = rotation.z - offsetRotation.z;
          if (scope.snap !== null) {
            if (scope.axis.search("X") != -1) {
              var rotsnap = Math.round(rotx / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - rotx) < scope.snapDelta) {
                rotx = rotsnap;
              }
            }
            if (scope.axis.search("Y") != -1) {
              var rotsnap = Math.round(roty / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - roty) < scope.snapDelta) {
                roty = rotsnap;
              }
            }
            if (scope.axis.search("Z") != -1) {
              var rotsnap = Math.round(rotz / scope.snap) * scope.snap;
              if (Math.abs(rotsnap - rotz) < scope.snapDelta) {
                rotz = rotsnap;
              }
            }
          }
          quaternionX.setFromAxisAngle(this.unitX, rotx);
          quaternionY.setFromAxisAngle(this.unitY, roty);
          quaternionZ.setFromAxisAngle(this.unitZ, rotz);
          quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

          if (scope.axis == "RX") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
          if (scope.axis == "RY") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
          if (scope.axis == "RZ") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);

          tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

          scope.object.quaternion.copy(tempQuaternion);

        }

        // show rotation end line
        if (_mode === "transrotate") {
          scope.add(scope.endLine);
          scope.add(scope.centerMark);
        }

      }

      // update matrix
      scope.object.matrixAutoUpdate = true;

      scope.update(true);
      scope.dispatchEvent(changeEvent);
      scope.dispatchEvent(objectChangeEvent);

      return planeIntersect ? true : false;

    };

    this.onPointerUp = function (event) {

      if (_dragging && scope.axis !== null) {
        mouseUpEvent.mode = _mode;
        scope.dispatchEvent(mouseUpEvent);
      }
      _dragging = false;

      this.gizmo[_mode].show();

      this.updateUnitVectors();

      // remove rotation start/end lines
      if (_mode === "transrotate" && this.gizmo[_mode].activeMode === "rotate") {
        this.remove(this.endLine);
        this.remove(this.centerMark);
        this.parent.remove(this.centerLine);
        this.parent.remove(this.startLine);
        this.parent.remove(this.ticks[this.axis]);
      }

      return false;

    };

    function intersectObjects(pointer, objects) {
      return THREE.TransformControls.intersectObjects(pointer.canvasX, pointer.canvasY, objects, camera, true);
    }
  };

  THREE.TransformControls.intersectObjects = function () {

    var pointerVector = new THREE.Vector3();
    var pointerDir = new THREE.Vector3();
    var ray = new THREE.Raycaster();

    return function (clientX, clientY, objects, camera, recursive) {

      // Convert client to viewport coords (in [-1,1]^2)
      var x = clientX / camera.clientWidth * 2 - 1;
      var y = -(clientY / camera.clientHeight) * 2 + 1; // y-direction flips between canvas and viewport coords

      if (camera.isPerspective) {
        pointerVector.set(x, y, 0.5);
        pointerVector.unproject(camera);
        ray.set(camera.position, pointerVector.sub(camera.position).normalize());
      } else {
        pointerVector.set(x, y, -1);
        pointerVector.unproject(camera);
        pointerDir.set(0, 0, -1);
        ray.set(pointerVector, pointerDir.transformDirection(camera.matrixWorld));
      }

      var intersections = ray.intersectObjects(objects, recursive);
      return intersections[0] ? intersections[0] : null;
    };
  }();

  THREE.TransformControls.prototype = Object.create(THREE.Object3D.prototype);

};

/***/ })

/******/ });
//# sourceMappingURL=Section.js.map