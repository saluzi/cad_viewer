/*!
 * LMV v7.1.0
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.CompGeom =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/CompGeom/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/CompGeom/complex-polygon.js":
/*!************************************************!*\
  !*** ./extensions/CompGeom/complex-polygon.js ***!
  \************************************************/
/*! exports provided: ComplexPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComplexPolygon", function() { return ComplexPolygon; });
/* harmony import */ var _poly2tri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./poly2tri */ "./extensions/CompGeom/poly2tri.js");
/* harmony import */ var _poly2tri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_poly2tri__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _interval_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interval-tree */ "./extensions/CompGeom/interval-tree.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var avp = Autodesk.Viewing.Private;
var logger = avp.logger;

function jitterPoints(pts) {

  for (var i = 0, iEnd = pts.length; i < iEnd; i++) {
    pts[i].x += (Math.random() - 0.5) * 1e-9;
    pts[i].y += (Math.random() - 0.5) * 1e-9;
  }

}

function copyPoints(pts, bbox) {

  //Moving poiints to be centered on the origin
  //seems to improve triangulation success rate, or
  //at least avoids some bugs in poly2yti

  var sz = bbox.size();
  var offsetx = bbox.min.x + sz.x * 0.5;
  var offsety = bbox.min.y + sz.y * 0.5;
  var scale = 2.0 / sz.length();

  var pts2 = [];

  for (var i = 0, iEnd = pts.length; i < iEnd; i++) {
    pts2.push({
      x: (pts[i].x - offsetx) * scale, // + (Math.random()-0.5) * 1e-9,
      y: (pts[i].y - offsety) * scale, // + (Math.random()-0.5) * 1e-9,
      _triidx: i + 1 });

  }

  return pts2;

}


//Represents a polygon with holes, and provides triangulation and mesh conversion utilities
var ComplexPolygon = /*#__PURE__*/function () {

  function ComplexPolygon(uniquePoints, customInsidechecker, bbox) {_classCallCheck(this, ComplexPolygon);
    this.pts = uniquePoints;
    this.contours = [];
    this.customInsideChecker = customInsidechecker;
    this.bbox = bbox;
  }_createClass(ComplexPolygon, [{ key: "addContour", value: function addContour(

    indices) {
      this.contours.push(indices);
    } }, { key: "pointInContour", value: function pointInContour(

    x, y, cntr) {
      var yflag0, yflag1;
      var vtx0X, vtx0Y, vtx1X, vtx1Y;

      var inside_flag = false;

      var pts = this.pts;

      // get the last point in the polygon
      vtx0X = pts[cntr[cntr.length - 1]].x;
      vtx0Y = pts[cntr[cntr.length - 1]].y;

      // get test bit for above/below X axis
      yflag0 = vtx0Y >= y;

      for (var j = 0, jEnd = cntr.length; j < jEnd; ++j)
      {
        vtx1X = pts[cntr[j]].x;
        vtx1Y = pts[cntr[j]].y;

        yflag1 = vtx1Y >= y;

        // Check if endpoints straddle (are on opposite sides) of X axis
        // (i.e. the Y's differ); if so, +X ray could intersect this edge.
        // The old test also checked whether the endpoints are both to the
        // right or to the left of the test point.  However, given the faster
        // intersection point computation used below, this test was found to
        // be a break-even proposition for most polygons and a loser for
        // triangles (where 50% or more of the edges which survive this test
        // will cross quadrants and so have to have the X intersection computed
        // anyway).  I credit Joseph Samosky with inspiring me to try dropping
        // the "both left or both right" part of my code.
        if (yflag0 != yflag1)
        {
          // Check intersection of pgon segment with +X ray.
          // Note if >= point's X; if so, the ray hits it.
          // The division operation is avoided for the ">=" test by checking
          // the sign of the first vertex wrto the test point; idea inspired
          // by Joseph Samosky's and Mark Haigh-Hutchinson's different
          // polygon inclusion tests.
          if ((vtx1Y - y) * (vtx0X - vtx1X) >=
          (vtx1X - x) * (vtx0Y - vtx1Y) == yflag1)
          {
            inside_flag = !inside_flag;
          }
        }

        // move to the next pair of vertices, retaining info as possible
        yflag0 = yflag1;
        vtx0X = vtx1X;
        vtx0Y = vtx1Y;
      }

      return inside_flag;
    } }, { key: "pointInPolygon", value: function pointInPolygon(


    x, y) {
      var inside = false;

      for (var i = 0; i < this.contours.length; i++) {

        if (this.pointInContour(x, y, this.contours[i]))
        inside = !inside;
      }

      return inside;
    } }, { key: "triangulate", value: function triangulate()

    {
      try {
        this.triangulateInternal();
      } catch (e) {

        if (e.message.indexOf("Collinear not supported!") !== -1) {
          try {
            this.triangulateInternal(true);
            //logger.log("Triangulation retry success.");
          } catch (e) {
            //logger.warn("Triangulation retry failed", e);
            this.triangulationFailed = true;
          }
        } else {
          //logger.warn("Triangulation failed", e);
          this.triangulationFailed = true;
        }
      }
    } }, { key: "createPointInPolygonChecker", value: function createPointInPolygonChecker()

    {

      var edges = [];

      for (var i = 0; i < this.contours.length; i++) {
        var cntr = this.contours[i];

        var len = cntr.length;
        for (var k = 0; k < len - 1; k++) {
          var e = {
            p1: cntr[k],
            p2: cntr[k + 1] };

          edges.push(e);
        }
      }

      var it = new _interval_tree__WEBPACK_IMPORTED_MODULE_1__["IntervalTree"](this.pts, edges, this.bbox);
      it.build();
      this.customInsideChecker = it;
    } }, { key: "triangulateInternal", value: function triangulateInternal(

    wantJitter) {

      if (!this.contours.length) {
        this.triangulationFailed = true;
        this.indices = null;
        return;
      }

      this.indices = [];

      var _pts = copyPoints(this.pts, this.bbox);

      if (wantJitter) {
        jitterPoints(_pts);
      }

      var sweepCtx = new _poly2tri__WEBPACK_IMPORTED_MODULE_0__["SweepContext"]([]);

      sweepCtx.points_ = _pts;

      for (var i = 0; i < this.contours.length; i++) {
        var cntr = this.contours[i];

        //Contour is not closed
        var isOpen = cntr[0] !== cntr[cntr.length - 1];

        //if (isOpen)
        //    continue;

        var len = isOpen ? cntr.length : cntr.length - 1;
        var edge = new Array(len);
        for (var k = 0; k < len; k++) {
          edge[k] = _pts[cntr[k]];
        }

        sweepCtx.initEdges(edge, isOpen);
      }

      sweepCtx.triangulate();

      this.processResult(sweepCtx);

      this.triangulationFailed = !this.indices || !this.indices.length;

    } }, { key: "processResult", value: function processResult(

    sweepCtx) {

      //If the polygon has a lot of vertices, create
      //an acceleration structure for point-in-polygon checks
      //so we can filter the triangles faster.
      if (this.pts.length > 10 && !this.customInsideChecker)
      this.createPointInPolygonChecker();

      var tris = sweepCtx.map_;
      for (var i = 0; i < tris.length; i++) {
        var tpts = tris[i].points_;
        var p0 = tpts[0];
        var p1 = tpts[1];
        var p2 = tpts[2];

        var i0 = p0._triidx;
        var i1 = p1._triidx;
        var i2 = p2._triidx;

        if (i0 && i1 && i2)
        this.filterFace(i0 - 1, i1 - 1, i2 - 1);

      }
    } }, { key: "filterFace", value: function filterFace(


    i0, i1, i2) {

      var p0 = this.pts[i0];
      var p1 = this.pts[i1];
      var p2 = this.pts[i2];

      var cx = (p0.x + p1.x + p2.x) / 3;
      var cy = (p0.y + p1.y + p2.y) / 3;

      var inside = this.customInsideChecker ? this.customInsideChecker.pointInPolygon(cx, cy) : this.pointInPolygon(cx, cy);

      if (inside) {

        var e1x = p1.x - p0.x;
        var e1y = p1.y - p0.y;
        var e2x = p2.x - p0.x;
        var e2y = p2.y - p0.y;

        var cross = e1x * e2y - e2x * e1y;

        if (cross > 0) {
          this.indices.push(i0, i1, i2);
        } else {
          this.indices.push(i0, i2, i1);
        }

      }
    }

    //creates a vertex buffer containing a filled 2D polygon for visualization on the cut plane
    //as 2D polygon mesh in the 3D model space
  }, { key: "toPolygonMesh", value: function toPolygonMesh(packNormals) {

      if (this.polygonMesh)
      return this.polygonMesh;

      var pts = this.pts;

      var bg = new THREE.BufferGeometry();

      var pos = new Float32Array(3 * pts.length);
      for (var j = 0; j < pts.length; j++) {
        pos[3 * j] = pts[j].x;
        pos[3 * j + 1] = pts[j].y;
        pos[3 * j + 2] = 0;
      }
      bg.addAttribute("position", new THREE.BufferAttribute(pos, 3));

      var normal = packNormals ? new Uint16Array(2 * pts.length) : new Float32Array(3 * pts.length);

      for (var _j = 0; _j < pts.length; _j++) {

        if (packNormals) {
          var pnx = (0 /*Math.atan2(0, 0)*/ / Math.PI + 1.0) * 0.5;
          var pny = (1.0 + 1.0) * 0.5;

          normal[_j * 2] = pnx * 65535 | 0;
          normal[_j * 2 + 1] = pny * 65535 | 0;
        } else {
          normal[3 * _j] = 0;
          normal[3 * _j + 1] = 0;
          normal[3 * _j + 2] = 1;
        }
      }

      bg.addAttribute("normal", new THREE.BufferAttribute(normal, packNormals ? 2 : 3));
      if (packNormals) {
        bg.attributes.normal.bytesPerItem = 2;
        bg.attributes.normal.normalize = true;
      }

      var index = new Uint16Array(this.indices.length);
      index.set(this.indices);

      bg.addAttribute("index", new THREE.BufferAttribute(index, 1));

      bg.streamingDraw = true;
      bg.streamingIndex = true;

      this.polygonMesh = bg;

      return bg;
    }


    //creates an extruded polygon 3d mesh
    //with the given thickness (maxZ=0, minZ=-thickness)
  }, { key: "toExtrudedMesh", value: function toExtrudedMesh(thickness) {

      if (this.extrudedMesh)
      return this.extrudedMesh;

      if (thickness === undefined)
      thickness = 1;

      //TODO: in case of failed triangulation
      //we can still generate a tube mesh with just the sides, without top and bottom caps
      if (!this.indices)
      return null;

      var vb = [];
      var indices = [];
      var iblines = [];
      var vbase = 0;

      //TODO: for better performance we can allocate ArrayBuffers up front with known
      //sizes... once the logic works.

      //Add the top and bottom polygons

      //The top is just the already triangulated 2D polygon
      //same as toPolygonMesh

      var pts = this.pts;
      for (var i = 0; i < pts.length; i++) {
        vb.push(pts[i].x, pts[i].y, 0);
        vb.push(0, 0, 1);
      }

      var inds = this.indices;

      for (var _i = 0; _i < inds.length; _i += 3) {
        indices.push(inds[_i], inds[_i + 1], inds[_i + 2]);
      }

      vbase += pts.length;

      //The bottom is like the top, but mirrored.

      for (var _i2 = 0; _i2 < pts.length; _i2++) {
        vb.push(pts[_i2].x, pts[_i2].y, -thickness);
        vb.push(0, 0, -1);
      }

      for (var _i3 = 0; _i3 < inds.length; _i3 += 3) {
        indices.push(vbase + inds[_i3], vbase + inds[_i3 + 2], vbase + inds[_i3 + 1]);
      }

      vbase += pts.length;

      //The sides -- each segment of the contours becomes a quad

      var tmp = new Vector3();
      var bbox = new Box3();

      for (var j = 0; j < this.contours.length; j++) {
        var cntr = this.contours[j];

        for (var _i4 = 0; _i4 < cntr.length - 1; _i4++) {

          //Add quad for each face formed by the extruded contour
          var x1 = this.pts[cntr[_i4]].x;
          var y1 = this.pts[cntr[_i4]].y;
          var z1 = 0;

          tmp.set(x1, y1, z1);
          bbox.expandByPoint(tmp);

          var x2 = this.pts[cntr[_i4 + 1]].x;
          var y2 = this.pts[cntr[_i4 + 1]].y;
          var z2 = 0;

          tmp.set(x2, y2, z2);
          bbox.expandByPoint(tmp);

          tmp.set(x1, y1, z1 - thickness);
          bbox.expandByPoint(tmp);

          //orthogonal to the face, will use for the normals
          tmp.set(y1 - y2, x2 - x1, 0).normalize();

          iblines.push(vbase, vbase + 1, vbase, vbase + 2, vbase + 1, vbase + 3, vbase + 2, vbase + 3);

          //If it's a hole, normals and faces are inverted
          if (j > 0) {

            vb.push(x1, y1, z1, -tmp.x, -tmp.y, -tmp.z,
            x2, y2, z2, -tmp.x, -tmp.y, -tmp.z,
            x1, y1, z1 - thickness, -tmp.x, -tmp.y, -tmp.z,
            x2, y2, z2 - thickness, -tmp.x, -tmp.y, -tmp.z);

            indices.push(vbase, vbase + 3, vbase + 2, vbase, vbase + 1, vbase + 3);
          } else {
            vb.push(x1, y1, z1, tmp.x, tmp.y, tmp.z,
            x2, y2, z2, tmp.x, tmp.y, tmp.z,
            x1, y1, z1 - thickness, tmp.x, tmp.y, tmp.z,
            x2, y2, z2 - thickness, tmp.x, tmp.y, tmp.z);

            indices.push(vbase, vbase + 2, vbase + 3, vbase + 0, vbase + 3, vbase + 1);
          }

          vbase += 4;
        }
      }

      //Convert to mesh suitable for rendering
      //TODO: As mentioned above, we can do this directly in the loop above
      //for better performance.

      var vbp = new Float32Array(vb.length);
      vbp.set(vb);

      var vbi = new Uint16Array(indices.length);
      vbi.set(indices);

      var vbili = new Uint16Array(iblines.length);
      vbili.set(iblines);

      var mdata = {
        mesh: {
          vb: vbp,
          indices: vbi,
          iblines: vbili,

          vbstride: 6,
          vblayout: {
            position: { offset: 0, itemSize: 3, bytesPerItem: 4 },
            normal: { offset: 3, itemSize: 3, bytesPerItem: 4 } },

          boundingBox: bbox,
          boundingSphere: { center: bbox.center(), radius: bbox.size().length * 0.5 } } };



      avp.BufferGeometryUtils.meshToGeometry(mdata);

      mdata.geometry.streamingDraw = true;
      mdata.geometry.streamingIndex = true;

      this.extrudedMesh = mdata.geometry;

      return this.extrudedMesh;
    } }]);return ComplexPolygon;}();

/***/ }),

/***/ "./extensions/CompGeom/contour-set.js":
/*!********************************************!*\
  !*** ./extensions/CompGeom/contour-set.js ***!
  \********************************************/
/*! exports provided: polygonArea, ContourSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonArea", function() { return polygonArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContourSet", function() { return ContourSet; });
/* harmony import */ var _complex_polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./complex-polygon */ "./extensions/CompGeom/complex-polygon.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


function polygonArea(pts) {

  if (pts.length < 3)
  return 0;

  var needsClose = false;
  if (pts[0] !== pts[pts.length - 1])
  needsClose = true;

  var total = 0;
  for (var i = 0, len = pts.length - 1; i < len; i++) {
    var v1 = pts[i];
    var _v = pts[i + 1];
    total += v1.x * _v.y - _v.x * v1.y;
  }

  if (needsClose) {
    var _v2 = pts[pts.length - 1];
    var _v3 = pts[0];
    total += _v2.x * _v3.y - _v3.x * _v2.y;
  }

  return total * 0.5;
}


var v2 = new THREE.Vector2();


//An intermediate complex polygon representation, used by the DCEL structure to compose and triangulate
//complex polygons, and also to convert the polygon data to various visualization representations
var ContourSet = /*#__PURE__*/function () {

  function ContourSet() {_classCallCheck(this, ContourSet);
    this.contours = [];
    this.areas = [];
    this.bbox = new THREE.Box2();

    this.allPoints = this.pts = [];
    this.allPointsMap = {};
  }_createClass(ContourSet, [{ key: "addContour", value: function addContour(

    verts, skipZeroAreas) {var _this = this;

      this.polygon = null;
      this.perimeterMem = undefined;

      var area = polygonArea(verts);

      if (area < 0) {
        verts.reverse();
        area = Math.abs(area);
      }

      var cntr = [];

      verts.forEach(function (v, i) {

        var id = v.id;

        if (typeof id === "undefined") {
          //Auto-assign unique vertex ID if not given -- this assumes the caller
          //has cleaned up the vertex data, or the polygon is simple enough not to
          //suffer from numeric issues.
          id = _this.contours.length + ":" + i;
        }

        var idx = _this.allPointsMap[id];
        if (idx === undefined) {
          idx = _this.allPoints.length;
          _this.allPoints.push(v);
          _this.allPointsMap[id] = idx;

          v2.set(v.x, v.y);
          _this.bbox.expandByPoint(v2);
        }
        cntr.push(idx);
      });

      if (area === 0 && skipZeroAreas)
      return;

      this.contours.push(cntr);
      this.areas.push(area);
    } }, { key: "addContourSet", value: function addContourSet(

    cset) {

      //TODO: this can be optimized to skip this pre-processing

      var cntr = cset.contours[0];
      var pts = cset.allPoints;

      var ptlist = cntr.map(function (idx) {return pts[idx];});

      this.addContour(ptlist);
    } }, { key: "triangulate", value: function triangulate(


    customInsideChecker) {

      if (this.polygon)
      return;

      var pts = this.allPoints;

      var polygon = new _complex_polygon__WEBPACK_IMPORTED_MODULE_0__["ComplexPolygon"](pts, customInsideChecker, this.bbox);

      polygon.contours = this.contours;

      polygon.triangulate();

      this.polygon = polygon;
      this.triangulationFailed = this.polygon.triangulationFailed;
    } }, { key: "area", value: function area()

    {
      return this.areas[0];
    } }, { key: "areaNet", value: function areaNet()

    {
      var total = this.areas[0];
      for (var i = 1; i < this.areas.length; i++) {
        total -= this.areas[i];}
      return total;
    } }, { key: "perimeter", value: function perimeter()

    {

      if (this.perimeterMem)
      return this.perimeterMem;

      var total = 0;
      var pts = this.contours[0];
      for (var i = 0, len = pts.length - 1; i < len; i++) {
        var v1 = pts[i];
        var _v4 = pts[i + 1];
        total += Math.sqrt((v1.x - _v4.x) * (v1.x - _v4.x) + (v1.y - _v4.y) * (v1.y - _v4.y));
      }

      this.perimeterMem = total;

      return total;
    } }, { key: "getThemeColor", value: function getThemeColor()


    {
      //returns a stable random-ish color value
      //based on properties of the geometry,
      //for use during colorized visualization of areas and volumes

      var r = this.areas[0] * 100 % 17 / 16;
      var g = this.allPoints.length % 23 / 22;
      var b = this.perimeterMem * 100 % 29 / 28;

      return { r: r, g: g, b: b };
    } }, { key: "hash", value: function hash()

    {var _this2 = this;
      var all = [];
      this.contours.forEach(function (c) {
        var vids = c.map(function (idx) {return _this2.allPoints[idx].id;});
        if (vids[0] === vids[vids.length - 1])
        vids.pop(); //remove last point that equals first point, since the same closed contour can use any of its points as a start point
        vids.sort();
        all.push(vids);
      });
      return JSON.stringify(all);
    } }, { key: "stitchContours", value: function stitchContours()


    {

      //invalidate this just in case something tries to use it...
      //it makes no sense for open polylines anyway
      this.areas = [];

      var openCntrs = [];
      for (var i = 0; i < this.contours.length; i++) {
        var cntr = this.contours[i];
        if (cntr[0] !== cntr[cntr.length - 1])
        openCntrs.push(cntr);
      }

      if (!openCntrs.length)
      return;


      var didSomething = true;
      while (didSomething) {

        didSomething = false;

        //Try to combine contours
        var cntr_edge_table = {};
        var contours = this.contours;

        for (var _i = 0; _i < contours.length; _i++) {
          var _cntr = contours[_i];

          var start = _cntr[0];
          var end = _cntr[_cntr.length - 1];

          if (start === end)
          continue;

          if (!cntr_edge_table[start])
          cntr_edge_table[start] = [-_i - 1];else

          cntr_edge_table[start].push(-_i - 1);


          if (!cntr_edge_table[end])
          cntr_edge_table[end] = [_i];else

          cntr_edge_table[end].push(_i);
        }

        for (var p in cntr_edge_table) {
          var entry = cntr_edge_table[p];

          if (entry.length === 2) {
            var toerase = undefined;

            if (entry[0] < 0 && entry[1] < 0) {
              var c1 = -entry[0] - 1;var c2 = -entry[1] - 1;
              //join start point to startpoint
              contours[c2].shift();
              Array.prototype.push.apply(contours[c1].reverse(), contours[c2]);
              toerase = c2;
            }

            if (entry[0] < 0 && entry[1] > 0) {
              var _c = -entry[0] - 1;var _c2 = entry[1];
              //join start point to endpoint
              contours[_c2].pop();
              Array.prototype.push.apply(contours[_c2], contours[_c]);
              toerase = _c;
            }

            if (entry[0] > 0 && entry[1] < 0) {
              var _c3 = entry[0];var _c4 = -entry[1] - 1;
              //join end point to startpoint
              contours[_c3].pop();
              Array.prototype.push.apply(contours[_c3], contours[_c4]);
              toerase = _c4;
            }

            if (entry[0] > 0 && entry[1] > 0) {
              var _c5 = entry[0];var _c6 = entry[1];
              //join end point to endpoint
              contours[_c5].pop();
              Array.prototype.push.apply(contours[_c5], contours[_c6].reverse());
              toerase = _c6;
            }

            if (toerase !== undefined) {
              contours.splice(toerase, 1);
              didSomething = true;
            }
            break;
          }
        }

      }

    } }, { key: "containsPointFrom", value: function containsPointFrom(


    cs2) {

      //Only need to check a single point from the interior of the
      //potential hole. Make sure it's inside the triangulation and not on the edge
      //to avoid numeric noise.
      if (!cs2.polygon.indices || cs2.polygon.indices.length < 3)
      return false;

      var p0 = cs2.allPoints[cs2.polygon.indices[0]];
      var p1 = cs2.allPoints[cs2.polygon.indices[1]];
      var p2 = cs2.allPoints[cs2.polygon.indices[2]];

      var cx = (p0.x + p1.x + p2.x) / 3;
      var cy = (p0.y + p1.y + p2.y) / 3;

      return this.polygon && this.polygon.pointInPolygon(cx, cy);
    }


    //creates a vertex buffer containing a filled 2D polygon for visualization on the cut plane
    //as 2D polygon mesh in the 3D model space
    //TODO: Use this directly from the this.polygon
  }, { key: "toPolygonMesh", value: function toPolygonMesh(packNormals) {

      return this.polygon.toPolygonMesh(packNormals);

    }

    //creates an extruded polygon 3d mesh
    //with the given thickness (maxZ=0, minZ=-thickness)
    //TODO: Use this directly from the this.polygon
  }, { key: "toExtrudedMesh", value: function toExtrudedMesh(thickness) {

      return this.polygon.toExtrudedMesh(thickness);
    } }]);return ContourSet;}();

/***/ }),

/***/ "./extensions/CompGeom/dcel.js":
/*!*************************************!*\
  !*** ./extensions/CompGeom/dcel.js ***!
  \*************************************/
/*! exports provided: DCEL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DCEL", function() { return DCEL; });
/* harmony import */ var _x_line_line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x-line-line */ "./extensions/CompGeom/x-line-line.js");
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");
/* harmony import */ var _contour_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contour-set */ "./extensions/CompGeom/contour-set.js");
/* harmony import */ var _quad_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quad-tree */ "./extensions/CompGeom/quad-tree.js");
/* harmony import */ var _point_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point-list */ "./extensions/CompGeom/point-list.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var avp = Autodesk.Viewing.Private;
var logger = avp.logger;var

Vertex = /*#__PURE__*/function () {

  function Vertex(x, y) {_classCallCheck(this, Vertex);
    this.x = x;
    this.y = y;

    this.edges = [];
    this.dbIds = [];
    this.dbIdsChanged = false;
  }_createClass(Vertex, [{ key: "isDegenerate", value: function isDegenerate()

    {
      return this.edges.length < 2;
    } }, { key: "addEdge", value: function addEdge(

    de) {

      //Make sure the same edge doesn't already exist
      for (var i = 0; i < this.edges.length; i++) {

        var e = this.edges[i];

        //We already have the exact same edge, return existing id
        if (e.v1 === de.v1 && e.v2 === de.v2)
        return e;
      }

      //Add the edge
      this.edges.push(de);
      return de;
    } }, { key: "removeEdge", value: function removeEdge(

    de) {
      var idx = this.edges.indexOf(de);
      if (idx >= 0)
      this.edges.splice(idx, 1);else

      logger.warn("Failed to find edge in vertex list");
    } }, { key: "findEdgeTo", value: function findEdgeTo(

    v) {
      for (var i = 0; i < this.edges.length; i++) {
        var e = this.edges[i];
        if (e.getOppositeVertex(this) === v)
        return e;
      }

      return null;
    }

    //TODO: make use of this when removing redundant vertices
  }, { key: "disconnect", value: function disconnect() {
      for (var i = 0; i < this.edges.length; i++) {
        var e = this.edges[i];
        e.getOppositeVertex(this).removeEdge(e);
      }

      var res = this.edges;
      this.edges = [];

      //Return the edges that got orphaned and need deletion 
      //from the parent structure
      return res;
    } }, { key: "sortEdges", value: function sortEdges()

    {var _this = this;

      this.edges.sort(function (a, b) {
        var angle1 = a.angle;
        if (a.v1 !== _this) {
          angle1 -= Math.PI;
        }

        var angle2 = b.angle;
        if (b.v1 !== _this) {
          angle2 -= Math.PI;
        }

        return angle1 - angle2;
      });

    } }, { key: "_canTraverse", value: function _canTraverse(

    e) {
      //forward edge
      if (e.v1 === this && !e.flagFwd) {
        e.flagFwd = 1;
        return true;
      }

      //reverse edge (points into this vertex)
      if (e.v2 === this && !e.flagRev) {
        e.flagRev = 1;
        return true;
      }

      return false;
    }

    //Returns an edge that's not yet traversed during
    //area finding
  }, { key: "findUntraversedEdge", value: function findUntraversedEdge() {
      for (var i = 0; i < this.edges.length; i++) {
        var e = this.edges[i];

        if (this._canTraverse(e))
        return e;
      }

      return null;
    }

    //Assuming edges are already sorted,
    //returns the edge that's immediately CCW to 
    //the given edge
  }, { key: "findNextCCWEdge", value: function findNextCCWEdge(e) {

      var idx = this.edges.indexOf(e);

      if (idx === -1) {
        logger.error("This edge isn't mine.");
        return null;
      }

      //Dangling vertex
      if (this.isDegenerate()) {
        return null;
      }
      /*        
                let idxNext = idx - 1;
                if (idxNext < 0)
                    idxNext = this.edges.length -1;
                    */
      var idxNext = (idx + 1) % this.edges.length;

      var eNext = this.edges[idxNext];

      if (this._canTraverse(eNext))
      return eNext;

      //logger.warn("Hmmm... Didn't find an edge to continue from here.");
      return null;
    } }]);return Vertex;}();var




DirectedEdge = /*#__PURE__*/function () {

  function DirectedEdge(v1, v2, id) {_classCallCheck(this, DirectedEdge);
    var swap = false;

    //Orient the edge so it has increasing dy and dx
    if (v2.y < v1.y)
    swap = true;else
    if (v2.y === v1.y)
    swap = v2.x < v1.x;

    //the coordinates stored in the edge
    //might be slightly different from the vertex coordinates
    //of the v1 and v2 vertices. The vertices are "snapped" to 
    //the nearest snap positin, while the edge coordinates are the "original" ones
    //from the 3d mesh that generated the edge.
    if (swap) {
      this.v1 = v2;
      this.v2 = v1;
    } else {
      this.v1 = v1;
      this.v2 = v2;
    }

    this.dx = this.v2.x - this.v1.x;
    this.dy = this.v2.y - this.v1.y;
    this.length2 = this.dx * this.dx + this.dy * this.dy;
    this.length = Math.sqrt(this.length2);
    this.angle = Math.atan2(this.dy, this.dx);

    if (this.angle < 0) {
      if (Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_1__["isZero"])(this.angle))
      this.angle = 0;else
      if (Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(this.angle, -Math.PI))
      this.angle = Math.PI;

      if (this.angle < 0)
      logger.warn("Unexpected edge slope <0 :", this.angle);
    }

    //the edge index in the edge list of the parent data structure
    this.id = id;

    this.minx = Math.min(this.v1.x, this.v2.x);
    this.miny = Math.min(this.v1.y, this.v2.y);
    this.maxx = Math.max(this.v1.x, this.v2.x);
    this.maxy = Math.max(this.v1.y, this.v2.y);


    //traversal flags, set temporarily 
    //during graph tarversal
    this.flagFwd = 0;
    this.flagRev = 0;

    this.dbIdsCached = null;
  }_createClass(DirectedEdge, [{ key: "paramAlong", value: function paramAlong(

    x, y) {
      var dot = (x - this.v1.x) * this.dx + (y - this.v1.y) * this.dy;
      return dot / this.length2;
    } }, { key: "getOppositeVertex", value: function getOppositeVertex(

    v) {
      if (this.v1 === v)
      return this.v2;else
      if (this.v2 === v)
      return this.v1;else

      logger.warn("Edge does not own this vertex.");
    } }, { key: "getDbIds", value: function getDbIds()

    {
      //Return all dbIds that are common between the two 
      //vertices of the edge. Used when splitting edges
      //to pass the information to new vertices

      if (!this.v1.dbIdsChanged && !this.v2.dbIdsChanged) {
        return this.dbIdsCached;
      }

      //Calculate intersection of the dbId arrays of
      //the two vertices.
      var res = [];
      var idv1 = this.v1.dbIds;
      var idv2 = this.v2.dbIds;
      for (var i = 0; i < idv1.length; i++) {
        if (idv2.indexOf(idv1[i]) !== -1)
        res.push(idv1[i]);
      }

      //Cache the result so we don't recompute unnecessarily
      //This requires cooperation by the vertex object change flag.
      this.dbIdsCached = res;
      this.v1.dbIdsChanged = false;
      this.v2.dbIdsChanged = false;

      return res;
    } }]);return DirectedEdge;}();




//doubly connected edge list
var DCEL = /*#__PURE__*/function () {


  function DCEL(bbox, precisionTolerance) {_classCallCheck(this, DCEL);

    this.bbox = bbox;
    this.boxSize = this.bbox.size().length();

    if (typeof precisionTolerance === "number") {
      //Input is in model units, e.g. if model is in feet,
      //precision tolerance has to be in feet
      this.precisionTolerance = precisionTolerance;
    } else {
      this.precisionTolerance = _fuzzy_math__WEBPACK_IMPORTED_MODULE_1__["TOL"] * this.boxSize;
    }

    this.edges = [];
    this.verts = new _point_list__WEBPACK_IMPORTED_MODULE_4__["UniquePointList"](this.bbox, this.precisionTolerance, Vertex, true);

    this.quadTreeEdges = new _quad_tree__WEBPACK_IMPORTED_MODULE_3__["QuadTree"](this.bbox.min.x, this.bbox.min.y, this.bbox.max.x, this.bbox.max.y, this.precisionTolerance);

    this.nextEdgeId = 1;
  }_createClass(DCEL, [{ key: "_addVertex", value: function _addVertex(

    px, py, dbIds) {
      return this.verts.findOrAddPoint(px, py, dbIds);
    } }, { key: "splitEdge", value: function splitEdge(


    de, points) {

      var pts = [];

      pts.push({
        x: de.v1.x,
        y: de.v1.y,
        u: 0 });


      //Remember the originating objects for this edge, to set them on the
      //resulting split edges
      var dbIds = de.getDbIds();

      for (var i = 0; i < points.length; i += 2) {

        var p = {
          x: points[i],
          y: points[i + 1],
          u: de.paramAlong(points[i], points[i + 1]) };


        if (Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_1__["isZero"])(p.u) || Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_1__["isEqual"])(p.u, 1))
        continue;

        pts.push(p);
      }

      //The intersection points were either on the beginning or on the end
      //vertex of the edge, so splitting is not needed as it will result
      //in a zero length edge.
      if (pts.length === 1)
      return;

      pts.push({
        x: de.v2.x,
        y: de.v2.y,
        u: 1 });


      pts.sort(function (a, b) {
        return a.u - b.u;
      });

      //Remove the source edge
      this.removeDirectedEdge(de);

      //Add all the pieces that the edge was split into
      for (var _i = 1; _i < pts.length; _i++) {
        this.addDirectedEdge(pts[_i - 1].x, pts[_i - 1].y, pts[_i].x, pts[_i].y, true, dbIds);
      }
    } }, { key: "_enumNearEdges", value: function _enumNearEdges(

    de, cb) {

      this.quadTreeEdges.enumNearItems(de, cb);
    } }, { key: "addDirectedEdge", value: function addDirectedEdge(

    x1, y1, x2, y2, skipSplitting, dbIds) {var _this2 = this;
      var v1 = this._addVertex(x1, y1, dbIds);
      var v2 = this._addVertex(x2, y2, dbIds);

      if (v1 === v2) {
        //logger.warn("zero length edge");
        return;
      }

      if (v1.findEdgeTo(v2)) {
        //edge already exists
        return;
      }

      var de = new DirectedEdge(v1, v2, this.nextEdgeId++);

      var addedEdge = de.v1.addEdge(de);

      //If the edge did not already exist...
      if (addedEdge === de) {
        de.v2.addEdge(de);

        //Remember the unsnapped positions used for this edge
        de.sourcePts = [x1, y1, x2, y2];

        this.edges[de.id] = de;

        this.quadTreeEdges.addItem(de);
      } else {
        //Edge is already in the graph, nothing to do
        return addedEdge;
      }

      if (skipSplitting)
      return addedEdge;

      //Now make sure the new edge doesn't overlap or intersect existing edges
      //by finding and splitting any intersecting edges
      var myInts = [];
      var otherInts = {};

      this._enumNearEdges(de, function (e) {
        var ints = Object(_x_line_line__WEBPACK_IMPORTED_MODULE_0__["segmentsIntersect"])(e, de, _this2.precisionTolerance);

        if (!ints)
        return;

        //Existing edge was crossed by new edge -- split it
        if (ints.e1 && ints.e1.length) {
          otherInts[e.id] = ints.e1;
        }

        //New edge crossed existing edge -- remember the intersection point for later
        if (ints.e2 && ints.e2.length) {
          myInts.push.apply(myInts, ints.e2);
        }

      });

      for (var id in otherInts) {
        this.splitEdge(this.edges[parseInt(id)], otherInts[id]);
      }

      if (myInts.length)
      this.splitEdge(de, myInts);

      this.dirty = true;

      return addedEdge;
    } }, { key: "removeDirectedEdge", value: function removeDirectedEdge(

    de) {

      de.v1.removeEdge(de);
      de.v2.removeEdge(de);

      this.edges[de.id] = undefined;

      this.quadTreeEdges.deleteItem(de);
    } }, { key: "removeDanglingPolyline", value: function removeDanglingPolyline(

    startVertex) {

      while (startVertex.edges.length === 1) {

        var de = startVertex.edges[0];
        var endVertex = de.getOppositeVertex(startVertex);
        this.removeDirectedEdge(de);
        startVertex = endVertex;
      }

    } }, { key: "cleanupFlatEdges", value: function cleanupFlatEdges()

    {
      //get rid of vertices that only have two parallel edges going into them

      var removeList = [];

      this.verts.forEach(function (v) {

        if (!v)
        return;

        if (v.edges.length !== 2)
        return;

        var e1 = v.edges[0];
        var e2 = v.edges[1];

        //Detect co-linear edges
        var angleDelta = Math.abs(e1.angle - e2.angle);
        var ANGLE_TOLERANCE = 2e-3;
        if (angleDelta < ANGLE_TOLERANCE || Math.abs(angleDelta - Math.PI) < ANGLE_TOLERANCE) {
          removeList.push(v);
        }

        //Detect degenerate triangles
        var v1 = e1.getOppositeVertex(v);
        var v2 = e2.getOppositeVertex(v);
        var eShared = v1.findEdgeTo(v2);

        if (eShared) {
          var area = 0.5 * Math.abs(e1.dx * e2.dy - e2.dx * e1.dy);
          if (area < 1e-3) {
            removeList.push(v);
          }
        }

        //TODO: more generic co-linearity and degeneracy heuristics...

      });


      //if (removeList.length)
      //    logger.log("Redundant edges", removeList.length);

      for (var i = 0; i < removeList.length; i++) {

        var v = removeList[i];

        if (v.edges.length !== 2) {
          //logger.warn("Number of edges changed");
          continue;
        }

        var e1 = v.edges[0];
        var e2 = v.edges[1];

        var vOther1 = e1.getOppositeVertex(v);
        var vOther2 = e2.getOppositeVertex(v);

        this.removeDirectedEdge(e1);
        this.removeDirectedEdge(e2);

        this.verts.delete(v);

        this.addDirectedEdge(vOther1.x, vOther1.y, vOther2.x, vOther2.y, true);
      }

      //Clean up again, until no more redundant vertices exist
      if (removeList.length)
      return this.cleanupFlatEdges();
    } }, { key: "_compactLists", value: function _compactLists()



    {

      this.verts.compact();


      var edges = [];

      for (var i = 0, len = this.edges.length; i < len; i++) {
        var e = this.edges[i];
        if (!e)
        continue;

        e.oldid = e.id;
        e.flagFwd = 0;
        e.flagRev = 0;
        e.id = edges.length;
        edges.push(e);
      }

      this.edges = edges;
    }


    //converts closed areas to polygons with holes, in a way where
    //holes themseves are also marked as separate polygons in their own
    //right, thus filling the whole area (i.e. non-zero fill method).
  }, { key: "_detectHolesNonZero", value: function _detectHolesNonZero(customInsideChecker) {

      this.holes = [];

      //Skip the very largest polygon, because that is
      //the overall model perimeter
      //TODO: This logic is Location Breakdown specific
      this.outerPerimeter = this.closedAreas[this.closedAreas.length - 1];
      if (this.outerPerimeter)
      this.outerPerimeter.triangulate();

      for (var i = 0, len = this.closedAreas.length - 1; i < len; i++) {

        var cs = this.closedAreas[i];

        //detect if the polygon is actually a hole in a
        //bigger exterior polygon
        //The logic we use here: if a polygon contains
        //any of the smaller polygons inside it, it is a hole of a bigger polygon
        //If a polygon contains a polygon marked as a hole, then add the hole to it
        //before triangulating.
        //TODO: this can be optimized via spatial index if number of polygons becomes large
        for (var j = i - 1; j >= 0; j--) {
          var cs2 = this.closedAreas[j];

          //Only need to check a single point from the interior of the
          //potential hole. Make sure it's inside the triangulation and not on the edge
          //to avoid numeric noise.
          if (cs.containsPointFrom(cs2)) {
            if (cs2.isHole) {
              cs.addContourSet(cs2);
            } else {
              cs.isHole = true;
              this.holes.push(cs);
              break;
            }
          }
        }

        //We added all the holes, now triangulate again with the holes in mind
        if (!cs.isHole) {
          cs.triangulate(customInsideChecker);
        }

      }


      //Do a second pass over just the holes
      //and convert each hole that contains a hole
      //to a real polygon area.
      //TODO: I don't really know if this is mathematically correct...
      for (var _i2 = 0, _len = this.holes.length; _i2 < _len; _i2++) {

        var _cs = this.holes[_i2];

        _cs.triangulate(customInsideChecker);

        //If a hole contains a hole inside it, then it is
        //no longer hole, mark both as processed
        for (var _j = _i2 - 1; _j >= 0; _j--) {

          var _cs2 = this.holes[_j];

          if (_cs2.holeProcessFlag)
          continue;

          //Only need to check a single point from the interior of the
          //potential hole. Make sure it's inside the triangulation and not on the edge
          //to avoid numeric noise.
          if (_cs.containsPointFrom(_cs2)) {
            _cs.addContourSet(_cs2);
            _cs.isHole = false;
            _cs2.holeProcessFlag = true;
          }
        }

        //We added all the holes, now triangulate again with the holes in mind
        if (!_cs.isHole) {
          _cs.triangulate(customInsideChecker);
        }

      }

      //Remove all holes from the list of polygons
      var filteredNonHoles = [];
      for (var _i3 = 0; _i3 < this.closedAreas.length - 1; _i3++) {
        var _cs3 = this.closedAreas[_i3];
        if (_cs3.isHole)
        continue;

        _cs3.id = filteredNonHoles.length;
        filteredNonHoles.push(_cs3);
      }

      this.closedAreas = filteredNonHoles;


    } }, { key: "_detectHolesEvenOdd", value: function _detectHolesEvenOdd(

    customInsideChecker) {

      var allAreas = this.closedAreas;
      if (this.openAreas && this.openAreas.length)
      allAreas = allAreas.concat(this.openAreas);

      if (!allAreas.length) {
        this.closedAreas = [];
        this.openAreas = null;
        return;
      }

      //In the DCEL, each polygon outline or hole contour
      //appears twice (due to the structure being doubly connected), so
      //here we drop the twin polygon.
      var cmap = {};
      var removed = 0;
      for (var i = 0; i < allAreas.length; i++) {
        var a = allAreas[i];
        var hash = a.hash();
        if (cmap[hash])
        removed++;else

        cmap[hash] = a;
      }

      //if (removed * 2 !== allAreas.length)
      //    logger.log("Unexpected duplicate count: removed", removed, "from", allAreas.length);

      allAreas = Object.values(cmap);

      //Make one giant complex polygon out of all the contours, and let
      //it triangulate itself using its default even-odd fill rule
      var csAll = new _contour_set__WEBPACK_IMPORTED_MODULE_2__["ContourSet"]();

      for (var _i4 = 0; _i4 < allAreas.length; _i4++) {
        csAll.addContourSet(allAreas[_i4]);
      }

      csAll.triangulate(customInsideChecker || this.quadTreeEdges);

      if (csAll.triangulationFailed) {
        //OK, now we get desperate -- the above triangulation attempt
        //of the whole thing as one failed, so we triangulate each
        //area separately (together with areas that are roughly inside it),
        //and filter that result based on even-odd inside checker.
        this._detectHolesNonZero(customInsideChecker || this.quadTreeEdges);
      } else {
        this.closedAreas = [csAll];
        this.openAreas = [];
      }
    } }, { key: "finalize", value: function finalize(


    useEvenOddFill, customInsideChecker) {

      //Remove useless vertices
      this.cleanupFlatEdges();

      this._compactLists();

      //Sort the edges of each vertex according to direction
      this.verts.forEach(function (v) {return v.sortEdges();});

      //traverse the graph and build closed polygons 
      //by following the edges in a counterclockwise direction

      var polygons = [];
      var openPolygons = [];

      this.verts.forEach(function (v) {
        var e = v.findUntraversedEdge();

        if (!e)
        return;

        var polygon = [v];

        var vNext = e.getOppositeVertex(v);
        do {
          polygon.push(vNext);
          e = vNext.findNextCCWEdge(e);
          if (!e)
          break;
          vNext = e.getOppositeVertex(vNext);
        } while (vNext && vNext !== v);

        if (vNext === v) {
          polygon.push(v);
          polygons.push(polygon);
        } else {
          openPolygons.push(polygon);
        }
      });

      //logger.log("closed polygons:", polygons.length);
      //if (openPolygons.length)
      //  logger.log("open polygons:", openPolygons.length);

      this.closedAreas = [];
      for (var i = 0, len = polygons.length; i < len; i++) {
        var cs = new _contour_set__WEBPACK_IMPORTED_MODULE_2__["ContourSet"]();
        cs.addContour(polygons[i]);
        this.closedAreas.push(cs);
      }

      //Sort by increasing area, so that
      //we discover potential polygon holes before we
      //triangulate their bigger exterior outlines
      this.closedAreas.sort(function (a, b) {
        return a.area() - b.area();
      });


      if (useEvenOddFill) {
        this._detectHolesEvenOdd(customInsideChecker);
      } else {
        this._detectHolesNonZero(customInsideChecker);
      }


      //Put all open polygons into a single set of contours
      //and combine as many as possible end to end to get
      //a minimal number of open contours.
      this.openAreas = [];
      if (openPolygons.length) {
        var openAreas = [];
        var _cs4 = new _contour_set__WEBPACK_IMPORTED_MODULE_2__["ContourSet"]();
        for (var _i5 = 0, _len2 = openPolygons.length; _i5 < _len2; _i5++) {
          _cs4.addContour(openPolygons[_i5]);
        }
        _cs4.stitchContours();
        _cs4.triangulate();
        openAreas.push(_cs4);
        //logger.log("Stitched open polygons", cs.contours.length);

        this.openAreas = openAreas;
      }

    } }, { key: "deleteEdgesOnLine", value: function deleteEdgesOnLine(


    x1, y1, x2, y2) {var _this3 = this;

      var v1Tmp = new Vertex(x1, y1);
      var v2Tmp = new Vertex(x2, y2);
      var deTmp = new DirectedEdge(v1Tmp, v2Tmp, -1);

      //Find edges crossed by the given segment
      var otherInts = {};

      this._enumNearEdges(deTmp, function (e) {

        var ints = Object(_x_line_line__WEBPACK_IMPORTED_MODULE_0__["segmentsIntersect"])(e, deTmp, _this3.precisionTolerance);

        if (!ints)
        return;

        //Existing edge was crossed by new edge
        if (ints.e1 && ints.e1.length) {
          otherInts[e.id] = ints.e1;
        }
      });

      //Remove the intersected edges, effectively
      //joining all areas defined by those edges.
      //This is brute force, in theory we can find all
      //contour sets that own the intersected edges
      //and update the triangulations, but it doesn't seem worth it
      for (var sid in otherInts) {
        var eid = parseInt(sid);
        var edge = this.edges[eid];
        this.removeDirectedEdge(edge);

        //clean up any "dangling" vertices left by the edge removal.
        //those are edges that are only connected to the deleted edge and nothing else
        this.removeDanglingPolyline(edge.v1);
        this.removeDanglingPolyline(edge.v2);
      }

      this.dirty = true;
    }

    //Given a rectangle, join all areas that intersect the rectangle
  }, { key: "deleteEdgesInRectangle", value: function deleteEdgesInRectangle(x1, y1, x2, y2) {

      var minx = Math.min(x1, x2);
      var miny = Math.min(y1, y2);
      var maxx = Math.max(x1, x2);
      var maxy = Math.max(y1, y2);

      var otherInts = {};

      //find edges completely inside the rectangle
      this.quadTreeEdges.enumInBox(minx, miny, maxx, maxy, function (e) {
        otherInts[e.id] = e;
      });

      //Remove the intersected edges, effectively
      //joining all areas defined by those edges.
      //This is brute force, in theory we can find all
      //contour sets that own the intersected edges
      //and update the triangulations, but it doesn't seem worth it
      for (var sid in otherInts) {
        var eid = parseInt(sid);
        var edge = this.edges[eid];

        if (!edge)
        continue;

        this.removeDirectedEdge(edge);

        //clean up any "dangling" vertices left by the edge removal.
        //those are edges that are only connected to the deleted edge and nothing else
        this.removeDanglingPolyline(edge.v1);
        this.removeDanglingPolyline(edge.v2);
      }


      this.dirty = true;
    } }, { key: "findNearestVertex", value: function findNearestVertex(

    x, y, radius) {

      if (typeof radius !== "number")
      radius = this.precisionTolerance;

      var dNear = Infinity;
      var vNear = null;

      this.verts.enumInBox(x - radius, y - radius, x + radius, y + radius, function (v) {

        var d = (v.x - x) * (v.x - x) + (v.y - y) * (v.y - y);
        if (d < dNear) {
          dNear = d;
          vNear = v;
        }

      });

      return dNear <= radius * radius ? vNear : null;
    } }, { key: "findNearestPointOnEdge", value: function findNearestPointOnEdge(

    x, y, radius) {

      if (typeof radius !== "number")
      radius = this.precisionTolerance;

      var tmp = { x: 0, y: 0, u: 0, d: -1 };
      var ptNearest = { x: 0, y: 0, d: Infinity, e: null };

      this.quadTreeEdges.enumInBox(x - radius, y - radius, x + radius, y + radius, function (e) {

        var result = Object(_x_line_line__WEBPACK_IMPORTED_MODULE_0__["pointOnLine"])(x, y, e, true, radius, tmp);

        if (result) {
          if (tmp.d < ptNearest.d) {
            ptNearest.x = tmp.x;
            ptNearest.y = tmp.y;
            ptNearest.d = tmp.d;
            ptNearest.e = e;
          }
        }
      });

      return ptNearest.d <= radius ? ptNearest : null;

    } }]);return DCEL;}();

/***/ }),

/***/ "./extensions/CompGeom/edge-set.js":
/*!*****************************************!*\
  !*** ./extensions/CompGeom/edge-set.js ***!
  \*****************************************/
/*! exports provided: EdgeSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeSet", function() { return EdgeSet; });
/* harmony import */ var _interval_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval-tree */ "./extensions/CompGeom/interval-tree.js");
/* harmony import */ var _point_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point-list */ "./extensions/CompGeom/point-list.js");
/* harmony import */ var _complex_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./complex-polygon */ "./extensions/CompGeom/complex-polygon.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var avp = Autodesk.Viewing.Private;

//Functionality for converting a list of two-point line segments into a connected
//set of (hopefully) closed contour lines. The contour set is then used
//for triangulation.
//This data structure assumes there are no intersecting edges (use the DCEL if there are, or you need fully-connected topology).
var EdgeSet = /*#__PURE__*/function () {

  function EdgeSet(edges, bbox, precisionTolerance) {_classCallCheck(this, EdgeSet);

    this.edges = edges;
    this.bbox = bbox;

    this.verts = new _point_list__WEBPACK_IMPORTED_MODULE_1__["UniquePointList"](bbox, precisionTolerance);
    this.polygon = null;
  }_createClass(EdgeSet, [{ key: "getPointIndex", value: function getPointIndex(


    px, py) {

      var v = this.verts.findOrAddPoint(px, py);

      return v.id;
    } }, { key: "snapEdges", value: function snapEdges()

    {

      for (var i = 0; i < this.edges.length; i++) {

        var e = this.edges[i];

        e.p1 = this.getPointIndex(e.v1.x, e.v1.y);
        e.p2 = this.getPointIndex(e.v2.x, e.v2.y);
      }
    } }, { key: "sanitizeEdges", value: function sanitizeEdges()

    {
      var edgeSet = {};
      var sanitizedEdges = [];

      for (var i = 0, len = this.edges.length; i < len; i++) {
        var e = this.edges[i];
        if (e.p1 === e.p2) {
          continue;
        }

        var key = Math.min(e.p1, e.p2) + ':' + Math.max(e.p1, e.p2);
        if (edgeSet[key] !== true) {
          edgeSet[key] = true;
          sanitizedEdges.push(e);
        }
      }

      this.edges = sanitizedEdges;
    } }, { key: "stitchContours", value: function stitchContours()


    {

      this.contours = [];

      //Create jump table from edge to edge
      //and back
      var edge_table = {};

      for (var i = 0; i < this.edges.length; i++) {
        var e = this.edges[i];

        if (e.p1 === e.p2)
        continue;

        if (edge_table[e.p1] !== undefined)
        edge_table[e.p1].push(e.p2);else

        edge_table[e.p1] = [e.p2];

        if (edge_table[e.p2] !== undefined)
        edge_table[e.p2].push(e.p1);else

        edge_table[e.p2] = [e.p1];
      }

      var cur_cntr = [];

      for (var p in edge_table) {
        if (edge_table[p].length !== 2) {
          avp.logger.warn("Incomplete edge table");
          break;
        }
      }

      //Start with the first edge, and stitch until we can no longer
      while (true) {

        var sfrom = undefined;

        //Look for doubly connected point first
        for (var p in edge_table) {
          if (edge_table[p].length > 1) {
            sfrom = p;
            break;
          }
        }

        //If no double-connected point found, we know
        //the it will be an open contour, but stitch as much
        //as we can anyway.
        if (!sfrom) {
          for (var p in edge_table) {
            if (edge_table[p].length > 0) {
              sfrom = p;
              break;
            }
          }
        }

        if (!sfrom)
        break;

        var prev = -1;
        var cur = parseInt(sfrom);
        var cur_segs = edge_table[sfrom];

        //start a new contour
        cur_cntr.push(cur);

        while (cur_segs && cur_segs.length) {

          var toPt = cur_segs.shift();

          //skip backpointer if we hit it
          if (toPt === prev)
          toPt = cur_segs.shift();

          if (toPt === undefined) {
            delete edge_table[cur];
            break;
          }

          cur_cntr.push(toPt);

          if (cur_segs.length == 0)
          delete edge_table[cur];else
          if (cur_segs[0] === prev)
          delete edge_table[cur];

          prev = cur;
          cur = toPt;
          cur_segs = edge_table[toPt];
        }

        if (cur_cntr.length) {
          this.contours.push(cur_cntr);
          cur_cntr = [];
        }
      }

      var openCntrs = [];
      for (var i = 0; i < this.contours.length; i++) {
        var cntr = this.contours[i];
        if (cntr[0] !== cntr[cntr.length - 1])
        openCntrs.push(cntr);
      }


      if (openCntrs.length) {
        //avp.logger.warn("Incomplete stitch");

        var didSomething = true;
        while (didSomething) {

          didSomething = false;

          //Try to combine contours
          var cntr_edge_table = {};
          var contours = this.contours;

          for (var i = 0; i < contours.length; i++) {
            var cntr = contours[i];
            var start = cntr[0];
            var end = cntr[cntr.length - 1];

            if (start === end)
            continue;

            if (!cntr_edge_table[start])
            cntr_edge_table[start] = [-i - 1];else

            cntr_edge_table[start].push(-i - 1);


            if (!cntr_edge_table[end])
            cntr_edge_table[end] = [i];else

            cntr_edge_table[end].push(i);
          }

          for (var p in cntr_edge_table) {
            var entry = cntr_edge_table[p];

            if (entry.length == 2) {
              var toerase = undefined;

              if (entry[0] < 0 && entry[1] < 0) {
                var c1 = -entry[0] - 1;var c2 = -entry[1] - 1;
                //join start point to startpoint
                contours[c2].shift();
                Array.prototype.push.apply(contours[c1].reverse(), contours[c2]);
                toerase = c2;
              }

              if (entry[0] < 0 && entry[1] > 0) {
                var c1 = -entry[0] - 1;var c2 = entry[1];
                //join start point to endpoint
                contours[c2].pop();
                Array.prototype.push.apply(contours[c2], contours[c1]);
                toerase = c1;
              }

              if (entry[0] > 0 && entry[1] < 0) {
                var c1 = entry[0];var c2 = -entry[1] - 1;
                //join end point to startpoint
                contours[c1].pop();
                Array.prototype.push.apply(contours[c1], contours[c2]);
                toerase = c2;
              }

              if (entry[0] > 0 && entry[1] > 0) {
                var c1 = entry[0];var c2 = entry[1];
                //join end point to endpoint
                contours[c1].pop();
                Array.prototype.push.apply(contours[c1], contours[c2].reverse());
                toerase = c2;
              }

              if (toerase !== undefined) {
                contours.splice(toerase, 1);
                didSomething = true;
              }
              break;
            }
          }

        }

      }
    } }, { key: "cleanupFlatEdges", value: function cleanupFlatEdges()


    {

      var pts = this.verts.pts;
      var TOL = this.verts.precisionTolerance;

      for (var i = 0; i < this.contours.length; i++) {

        var cntr = this.contours[i];

        while (true) {


          var removePt = -1;

          for (var j = 1; j < cntr.length - 1; j++) {
            var prev = cntr[j - 1];
            var cur = cntr[j];
            var next = cntr[j + 1];

            var p0 = pts[prev];
            var p1 = pts[cur];
            var p2 = pts[next];

            var dx1 = p1.x - p0.x;
            var dy1 = p1.y - p0.y;
            var dx2 = p2.x - p1.x;
            var dy2 = p2.y - p1.y;

            var len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            if (len1 < TOL) {
              removePt = j;
              break;
            }

            var len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            if (len2 < TOL) {
              removePt = j;
              break;
            }

            dx1 /= len1;
            dy1 /= len1;
            dx2 /= len2;
            dy2 /= len2;

            var dot = dx1 * dx2 + dy1 * dy2;

            if (Math.abs(dot - 1.0) < 1e-2) {
              removePt = j;
              break;
            }
          }

          if (removePt < 0)
          break;

          cntr.splice(removePt, 1);
        }

      }

    } }, { key: "triangulate", value: function triangulate()


    {

      //this.cleanupFlatEdges();

      //The interval tree is a faster and more tolerant
      //way of checking if a point is inside the complex polygon defined
      //by a set of edges. We use that in preference to the built-in
      //ComplexPolygon inside checker.
      var it = new _interval_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalTree"](this.verts.pts, this.edges, this.bbox);
      it.build();

      var polygon = new _complex_polygon__WEBPACK_IMPORTED_MODULE_2__["ComplexPolygon"](this.verts.pts, it, this.bbox);
      polygon.contours = this.contours;
      polygon.triangulate();
      return polygon;

    } }]);return EdgeSet;}();

/***/ }),

/***/ "./extensions/CompGeom/fuzzy-math.js":
/*!*******************************************!*\
  !*** ./extensions/CompGeom/fuzzy-math.js ***!
  \*******************************************/
/*! exports provided: TOL, isZero, isEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOL", function() { return TOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isZero", function() { return isZero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });

var TOL = 1e-6;

function isZero(f) {
  return Math.abs(f) < TOL;
}

function isEqual(a, b) {
  return isZero(a - b);
}

/***/ }),

/***/ "./extensions/CompGeom/index.js":
/*!**************************************!*\
  !*** ./extensions/CompGeom/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}
var av = Autodesk.Viewing;
var avecg = AutodeskNamespace('Autodesk.Viewing.Extensions.CompGeom');

function _export(m, ns) {
  for (var prop in m) {
    if (m.hasOwnProperty(prop)) {
      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)
      module.exports[prop] = m[prop];

      //Export into the desired viewer namespace
      ns[prop] = m[prop];
    }
  }
}

_export(__webpack_require__(/*! ./contour-set */ "./extensions/CompGeom/contour-set.js"), avecg);
_export(__webpack_require__(/*! ./edge-set */ "./extensions/CompGeom/edge-set.js"), avecg);
_export(__webpack_require__(/*! ./dcel */ "./extensions/CompGeom/dcel.js"), avecg);
_export(__webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js"), avecg);
_export(__webpack_require__(/*! ./quad-tree */ "./extensions/CompGeom/quad-tree.js"), avecg);
_export(__webpack_require__(/*! ./x-box-box */ "./extensions/CompGeom/x-box-box.js"), avecg);
_export(__webpack_require__(/*! ./x-box-plane */ "./extensions/CompGeom/x-box-plane.js"), avecg);
_export(__webpack_require__(/*! ./x-line-box */ "./extensions/CompGeom/x-line-box.js"), avecg);
_export(__webpack_require__(/*! ./x-line-line */ "./extensions/CompGeom/x-line-line.js"), avecg);
_export(__webpack_require__(/*! ./x-mesh-plane */ "./extensions/CompGeom/x-mesh-plane.js"), avecg);
_export(__webpack_require__(/*! ./x-plane-segment */ "./extensions/CompGeom/x-plane-segment.js"), avecg);
_export(__webpack_require__(/*! ./x-triangle-plane */ "./extensions/CompGeom/x-triangle-plane.js"), avecg);
_export(__webpack_require__(/*! ./interval-tree */ "./extensions/CompGeom/interval-tree.js"), avecg);
_export(__webpack_require__(/*! ./complex-polygon */ "./extensions/CompGeom/complex-polygon.js"), avecg);
_export(__webpack_require__(/*! ./point-list */ "./extensions/CompGeom/point-list.js"), avecg);
_export(__webpack_require__(/*! ./poly2tri */ "./extensions/CompGeom/poly2tri.js"), avecg);

/**
                                        * Computational geometry library extension
                                        */var
CompGeomExtension = /*#__PURE__*/function (_av$Extension) {_inherits(CompGeomExtension, _av$Extension);

  function CompGeomExtension(viewer, options) {_classCallCheck(this, CompGeomExtension);return _possibleConstructorReturn(this, _getPrototypeOf(CompGeomExtension).call(this,
    viewer, options));
  }_createClass(CompGeomExtension, [{ key: "load", value: function load()

    {return true;} }, { key: "unload", value: function unload()
    {return true;} }, { key: "activate", value: function activate()
    {return true;} }, { key: "deactivate", value: function deactivate()
    {return false;} }]);return CompGeomExtension;}(av.Extension);


// The ExtensionManager requires an extension to be registered.
av.theExtensionManager.registerExtension('Autodesk.CompGeom', CompGeomExtension);

/***/ }),

/***/ "./extensions/CompGeom/interval-tree.js":
/*!**********************************************!*\
  !*** ./extensions/CompGeom/interval-tree.js ***!
  \**********************************************/
/*! exports provided: IntervalTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalTree", function() { return IntervalTree; });
function IntervalNode() {

  this.bbox = new THREE.Box2();
  this.left = null;
  this.right = null;
  this.node_edges = [];
}

//Acceleration structure for point-in-polygon checking.
//Takes in a list of points and edges indexing into those points.
//The Point-in-polygon check is a simple even-odd test based on counting
//number of edges intersected by a ray from the input point to infinity.
function IntervalTree(pts, edges, bbox) {

  this.pts = pts;
  this.edges = edges;
  this.bbox = bbox;
  this.pipResult = false;

}



IntervalTree.prototype.splitNode = function (node) {

  if (node.bbox.min.y >= node.bbox.max.y)
  return;

  if (node.node_edges.length < 3)
  return;

  var split = 0.5 * (node.bbox.min.y + node.bbox.max.y);

  //node.bbox.makeEmpty();

  node.left = new IntervalNode();
  node.right = new IntervalNode();

  var pts = this.pts;
  var ne = node.node_edges;
  var remaining_node_edges = [];
  var tmpPt = new THREE.Vector2();

  for (var i = 0; i < ne.length; i++) {

    var e = this.edges[ne[i]];

    var p1y = pts[e.p1].y;
    var p2y = pts[e.p2].y;

    if (p1y > p2y) {
      var tmp = p1y;
      p1y = p2y;
      p2y = tmp;
    }

    var boxPtr = null;

    if (p2y < split) {
      node.left.node_edges.push(ne[i]);
      boxPtr = node.left.bbox;
    } else if (p1y > split) {
      node.right.node_edges.push(ne[i]);
      boxPtr = node.right.bbox;
    } else {
      remaining_node_edges.push(ne[i]);
      //boxPtr = node.bbox;
    }

    if (boxPtr) {
      tmpPt.set(pts[e.p1].x, pts[e.p1].y);
      boxPtr.expandByPoint(tmpPt);
      tmpPt.set(pts[e.p2].x, pts[e.p2].y);
      boxPtr.expandByPoint(tmpPt);
    }
  }

  node.node_edges = remaining_node_edges;

  if (node.left.node_edges.length)
  this.splitNode(node.left);
  if (node.right.node_edges.length)
  this.splitNode(node.right);
};


IntervalTree.prototype.build = function () {

  this.root = new IntervalNode();

  var edge_indices = this.root.node_edges;
  for (var i = 0; i < this.edges.length; i++) {
    edge_indices.push(i);}

  this.root.bbox.copy(this.bbox);

  //split recursively
  this.splitNode(this.root);
};




IntervalTree.prototype.pointInPolygonRec = function (node, x, y) {

  if (node.bbox.min.y <= y && node.bbox.max.y >= y) {

    var pts = this.pts;
    var ne = node.node_edges;

    for (var i = 0, iEnd = ne.length; i < iEnd; i++) {

      var e = this.edges[ne[i]];

      // get the last point in the polygon
      var p1 = pts[e.p1];
      var vtx0X = p1.x;
      var vtx0Y = p1.y;

      // get test bit for above/below X axis
      var yflag0 = vtx0Y >= y;

      var p2 = pts[e.p2];
      var vtx1X = p2.x;
      var vtx1Y = p2.y;

      var yflag1 = vtx1Y >= y;

      // Check if endpoints straddle (are on opposite sides) of X axis
      // (i.e. the Y's differ); if so, +X ray could intersect this edge.
      // The old test also checked whether the endpoints are both to the
      // right or to the left of the test point.  However, given the faster
      // intersection point computation used below, this test was found to
      // be a break-even proposition for most polygons and a loser for
      // triangles (where 50% or more of the edges which survive this test
      // will cross quadrants and so have to have the X intersection computed
      // anyway).  I credit Joseph Samosky with inspiring me to try dropping
      // the "both left or both right" part of my code.
      if (yflag0 != yflag1)
      {
        // Check intersection of pgon segment with +X ray.
        // Note if >= point's X; if so, the ray hits it.
        // The division operation is avoided for the ">=" test by checking
        // the sign of the first vertex wrto the test point; idea inspired
        // by Joseph Samosky's and Mark Haigh-Hutchinson's different
        // polygon inclusion tests.
        if ((vtx1Y - y) * (vtx0X - vtx1X) >=
        (vtx1X - x) * (vtx0Y - vtx1Y) == yflag1)
        {
          this.pipResult = !this.pipResult;
        }
      }

    }

  }

  var nl = node.left;
  if (nl && nl.bbox.min.y <= y && nl.bbox.max.y >= y) {
    this.pointInPolygonRec(nl, x, y);
  }

  var nr = node.right;
  if (nr && nr.bbox.min.y <= y && nr.bbox.max.y >= y) {
    this.pointInPolygonRec(nr, x, y);
  }

};

IntervalTree.prototype.pointInPolygon = function (x, y) {

  this.pipResult = false;

  this.pointInPolygonRec(this.root, x, y);

  return this.pipResult;

};

/***/ }),

/***/ "./extensions/CompGeom/point-list.js":
/*!*******************************************!*\
  !*** ./extensions/CompGeom/point-list.js ***!
  \*******************************************/
/*! exports provided: UniquePointList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniquePointList", function() { return UniquePointList; });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");
/* harmony import */ var _quad_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad-tree */ "./extensions/CompGeom/quad-tree.js");
/* harmony import */ var _poly2tri__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./poly2tri */ "./extensions/CompGeom/poly2tri.js");
/* harmony import */ var _poly2tri__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_poly2tri__WEBPACK_IMPORTED_MODULE_2__);
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var UniquePointList = /*#__PURE__*/function () {

  function UniquePointList(bbox, precisionTolerance, VertexConstructor, useQuadTree) {_classCallCheck(this, UniquePointList);

    this.bbox = bbox;
    this.boxSize = this.bbox.size().length();

    if (typeof precisionTolerance === "number") {
      //Input is in model units, e.g. if model is in feet,
      //precision tolerance has to be in feet
      this.precisionTolerance = precisionTolerance;
      this.scale = 1.0 / this.precisionTolerance;
    } else {
      this.precisionTolerance = _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] * this.boxSize;
      this.scale = 1.0 / this.precisionTolerance;
    }

    this.snapBaseX = this.bbox.min.x; ///- 0.5 * this.precisionTolerance;
    this.snapBaseY = this.bbox.min.y; //- 0.5 * this.precisionTolerance;


    this.pts = [];
    this.xymap = {};

    if (useQuadTree)
    this.quadTreeVerts = new _quad_tree__WEBPACK_IMPORTED_MODULE_1__["QuadTree"](bbox.min.x, bbox.min.y, bbox.max.x, bbox.max.y, precisionTolerance);

    this.vertexConstructor = VertexConstructor;
  }_createClass(UniquePointList, [{ key: "findOrAddPoint", value: function findOrAddPoint(

    px, py, dbIds) {

      //Snap the vertex to our desired granularity
      var x = 0 | /*Math.round*/(px - this.snapBaseX) * this.scale;
      var y = 0 | /*Math.round*/(py - this.snapBaseY) * this.scale;

      //Find the nearest snapped vertex or create new
      var v;
      var minDist = Infinity;
      //Look in the 9 square area surrounding the vertex
      for (var i = x - 1; i <= x + 1; i++) {
        var mx = this.xymap[i];
        if (!mx)
        continue;

        for (var j = y - 1; j <= y + 1; j++) {
          var tmp = mx[j];
          if (!tmp)
          continue;

          var dist = (tmp.x - px) * (tmp.x - px) + (tmp.y - py) * (tmp.y - py);

          if (dist < minDist) {
            v = tmp;
            minDist = dist;
          }
        }
      }

      if (Math.sqrt(minDist) > this.precisionTolerance)
      v = undefined;

      if (v === undefined) {
        var _mx = this.xymap[x];

        if (!_mx) {
          _mx = this.xymap[x] = {};
        }

        v = this.vertexConstructor ? new this.vertexConstructor(px, py) : new _poly2tri__WEBPACK_IMPORTED_MODULE_2__["Point"](px, py);
        _mx[y] = v;
        v.id = this.pts.length;
        this.pts.push(v);

        if (this.quadTreeVerts)
        this.quadTreeVerts.addItem(v);
      }

      //Remember the source object that's adding this vertex
      if (typeof dbIds !== "undefined") {
        if (typeof dbIds === "number") {
          if (v.dbIds.indexOf(dbIds) === -1)
          v.dbIds.push(dbIds);
        } else if (dbIds) {
          for (var _i = 0; _i < dbIds.length; _i++) {
            var dbId = dbIds[_i];
            if (v.dbIds.indexOf(dbId) === -1)
            v.dbIds.push(dbId);
          }
        }
        v.dbIdsChanged = true;
      }

      return v;
    } }, { key: "forEach", value: function forEach(


    f) {
      this.pts.forEach(f);
    } }, { key: "delete", value: function _delete(

    v) {
      this.pts[v.id] = undefined;

      if (this.quadTreeVerts)
      this.quadTreeVerts.deleteItem(v);
    }

    //filters out null entries from the point list
  }, { key: "compact", value: function compact() {

      var pts = [];

      for (var i = 0, len = this.pts.length; i < len; i++) {
        var v = this.pts[i];
        if (!v)
        continue;

        v.oldid = v.id;
        v.id = pts.length;
        pts.push(v);
      }

      this.pts = pts;

    } }, { key: "enumInBox", value: function enumInBox(

    minx, miny, maxx, maxy, f) {
      this.quadTreeVerts.enumInBox(minx, miny, maxx, maxy, f);
    } }]);return UniquePointList;}();

/***/ }),

/***/ "./extensions/CompGeom/poly2tri.js":
/*!*****************************************!*\
  !*** ./extensions/CompGeom/poly2tri.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}(function (f) {if (( false ? undefined : _typeof(exports)) === "object" && typeof module !== "undefined") {module.exports = f();} else if (true) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));} else { var g; }})(function () {var define, module, exports;return function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {var a = typeof require == "function" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {var n = t[o][1][e];return s(n ? n : e);}, l, l.exports, e, t, n, r);}return n[o].exports;}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {s(r[o]);}return s;}({ 1: [function (require, module, exports) {
      module.exports = { "version": "1.5.0" };
    }, {}], 2: [function (require, module, exports) {
      /*
                                                      * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                      * http://code.google.com/p/poly2tri/
                                                      * 
                                                      * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                      * https://github.com/r3mi/poly2tri.js
                                                      * 
                                                      * All rights reserved.
                                                      * 
                                                      * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                      */

      /* jshint maxcomplexity:11 */

      "use strict";


      /*
                     * Note
                     * ====
                     * the structure of this JavaScript version of poly2tri intentionally follows
                     * as closely as possible the structure of the reference C++ version, to make it 
                     * easier to keep the 2 versions in sync.
                     */


      // -------------------------------------------------------------------------Node

      /**
       * Advancing front node
       * @constructor
       * @private
       * @struct
       * @param {!XY} p - Point
       * @param {Triangle=} t triangle (optional)
       */
      var Node = function Node(p, t) {
        /** @type {XY} */
        this.point = p;

        /** @type {Triangle|null} */
        this.triangle = t || null;

        /** @type {Node|null} */
        this.next = null;
        /** @type {Node|null} */
        this.prev = null;

        /** @type {number} */
        this.value = p.x;
      };

      // ---------------------------------------------------------------AdvancingFront
      /**
       * @constructor
       * @private
       * @struct
       * @param {Node} head
       * @param {Node} tail
       */
      var AdvancingFront = function AdvancingFront(head, tail) {
        /** @type {Node} */
        this.head_ = head;
        /** @type {Node} */
        this.tail_ = tail;
        /** @type {Node} */
        this.search_node_ = head;
      };

      /** @return {Node} */
      AdvancingFront.prototype.head = function () {
        return this.head_;
      };

      /** @param {Node} node */
      AdvancingFront.prototype.setHead = function (node) {
        this.head_ = node;
      };

      /** @return {Node} */
      AdvancingFront.prototype.tail = function () {
        return this.tail_;
      };

      /** @param {Node} node */
      AdvancingFront.prototype.setTail = function (node) {
        this.tail_ = node;
      };

      /** @return {Node} */
      AdvancingFront.prototype.search = function () {
        return this.search_node_;
      };

      /** @param {Node} node */
      AdvancingFront.prototype.setSearch = function (node) {
        this.search_node_ = node;
      };

      /** @return {Node} */
      AdvancingFront.prototype.findSearchNode = function () /*x*/{
        // TODO: implement BST index
        return this.search_node_;
      };

      /**
          * @param {number} x value
          * @return {Node}
          */
      AdvancingFront.prototype.locateNode = function (x) {
        var node = this.search_node_;

        /* jshint boss:true */
        if (x < node.value) {
          while (node = node.prev) {
            if (x >= node.value) {
              this.search_node_ = node;
              return node;
            }
          }
        } else {
          while (node = node.next) {
            if (x < node.value) {
              this.search_node_ = node.prev;
              return node.prev;
            }
          }
        }
        return null;
      };

      /**
          * @param {!XY} point - Point
          * @return {Node}
          */
      AdvancingFront.prototype.locatePoint = function (point) {
        var px = point.x;
        var node = this.findSearchNode(px);
        var nx = node.point.x;

        if (px === nx) {
          // Here we are comparing point references, not values
          if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
              node = node.prev;
            } else if (point === node.next.point) {
              node = node.next;
            } else {
              throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
          }
        } else if (px < nx) {
          /* jshint boss:true */
          while (node = node.prev) {
            if (point === node.point) {
              break;
            }
          }
        } else {
          while (node = node.next) {
            if (point === node.point) {
              break;
            }
          }
        }

        if (node) {
          this.search_node_ = node;
        }
        return node;
      };


      // ----------------------------------------------------------------------Exports

      module.exports = AdvancingFront;
      module.exports.Node = Node;


    }, {}], 3: [function (require, module, exports) {
      /*
                                                      * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                      * http://code.google.com/p/poly2tri/
                                                      *
                                                      * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                      * https://github.com/r3mi/poly2tri.js
                                                      *
                                                      * All rights reserved.
                                                      *
                                                      * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                      */

      "use strict";

      /*
                     * Function added in the JavaScript version (was not present in the c++ version)
                     */

      /**
                         * assert and throw an exception.
                         *
                         * @private
                         * @param {boolean} condition   the condition which is asserted
                         * @param {string} message      the message which is display is condition is falsy
                         */
      function assert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assert Failed");
        }
      }
      module.exports = assert;



    }, {}], 4: [function (require, module, exports) {
      /*
                                                      * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                      * http://code.google.com/p/poly2tri/
                                                      * 
                                                      * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                      * https://github.com/r3mi/poly2tri.js
                                                      * 
                                                      * All rights reserved.
                                                      * 
                                                      * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                      */

      "use strict";


      /*
                     * Note
                     * ====
                     * the structure of this JavaScript version of poly2tri intentionally follows
                     * as closely as possible the structure of the reference C++ version, to make it 
                     * easier to keep the 2 versions in sync.
                     */

      var xy = require('./xy');

      // ------------------------------------------------------------------------Point
      /**
       * Construct a point
       * @example
       *      var point = new poly2tri.Point(150, 150);
       * @public
       * @constructor
       * @struct
       * @param {number=} x    coordinate (0 if undefined)
       * @param {number=} y    coordinate (0 if undefined)
       */
      var Point = function Point(x, y) {
        /**
                                         * @type {number}
                                         * @expose
                                         */
        this.x = +x || 0;
        /**
                           * @type {number}
                           * @expose
                           */
        this.y = +y || 0;

        // All extra fields added to Point are prefixed with _p2t_
        // to avoid collisions if custom Point class is used.

        /**
         * The edges this point constitutes an upper ending point
         * @private
         * @type {Array.<Edge>}
         */
        this._p2t_edge_list = null;
      };

      /**
          * For pretty printing
          * @example
          *      "p=" + new poly2tri.Point(5,42)
          *      // → "p=(5;42)"
          * @returns {string} <code>"(x;y)"</code>
          */
      Point.prototype.toString = function () {
        return xy.toStringBase(this);
      };

      /**
          * JSON output, only coordinates
          * @example
          *      JSON.stringify(new poly2tri.Point(1,2))
          *      // → '{"x":1,"y":2}'
          */
      Point.prototype.toJSON = function () {
        return { x: this.x, y: this.y };
      };

      /**
          * Creates a copy of this Point object.
          * @return {Point} new cloned point
          */
      Point.prototype.clone = function () {
        return new Point(this.x, this.y);
      };

      /**
          * Set this Point instance to the origo. <code>(0; 0)</code>
          * @return {Point} this (for chaining)
          */
      Point.prototype.set_zero = function () {
        this.x = 0.0;
        this.y = 0.0;
        return this; // for chaining
      };

      /**
          * Set the coordinates of this instance.
          * @param {number} x   coordinate
          * @param {number} y   coordinate
          * @return {Point} this (for chaining)
          */
      Point.prototype.set = function (x, y) {
        this.x = +x || 0;
        this.y = +y || 0;
        return this; // for chaining
      };

      /**
          * Negate this Point instance. (component-wise)
          * @return {Point} this (for chaining)
          */
      Point.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this; // for chaining
      };

      /**
          * Add another Point object to this instance. (component-wise)
          * @param {!Point} n - Point object.
          * @return {Point} this (for chaining)
          */
      Point.prototype.add = function (n) {
        this.x += n.x;
        this.y += n.y;
        return this; // for chaining
      };

      /**
          * Subtract this Point instance with another point given. (component-wise)
          * @param {!Point} n - Point object.
          * @return {Point} this (for chaining)
          */
      Point.prototype.sub = function (n) {
        this.x -= n.x;
        this.y -= n.y;
        return this; // for chaining
      };

      /**
          * Multiply this Point instance by a scalar. (component-wise)
          * @param {number} s   scalar.
          * @return {Point} this (for chaining)
          */
      Point.prototype.mul = function (s) {
        this.x *= s;
        this.y *= s;
        return this; // for chaining
      };

      /**
          * Return the distance of this Point instance from the origo.
          * @return {number} distance
          */
      Point.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };

      /**
          * Normalize this Point instance (as a vector).
          * @return {number} The original distance of this instance from the origo.
          */
      Point.prototype.normalize = function () {
        var len = this.length();
        this.x /= len;
        this.y /= len;
        return len;
      };

      /**
          * Test this Point object with another for equality.
          * @param {!XY} p - any "Point like" object with {x,y}
          * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
          */
      Point.prototype.equals = function (p) {
        return this.x === p.x && this.y === p.y;
      };


      // -----------------------------------------------------Point ("static" methods)

      /**
       * Negate a point component-wise and return the result as a new Point object.
       * @param {!XY} p - any "Point like" object with {x,y}
       * @return {Point} the resulting Point object.
       */
      Point.negate = function (p) {
        return new Point(-p.x, -p.y);
      };

      /**
          * Add two points component-wise and return the result as a new Point object.
          * @param {!XY} a - any "Point like" object with {x,y}
          * @param {!XY} b - any "Point like" object with {x,y}
          * @return {Point} the resulting Point object.
          */
      Point.add = function (a, b) {
        return new Point(a.x + b.x, a.y + b.y);
      };

      /**
          * Subtract two points component-wise and return the result as a new Point object.
          * @param {!XY} a - any "Point like" object with {x,y}
          * @param {!XY} b - any "Point like" object with {x,y}
          * @return {Point} the resulting Point object.
          */
      Point.sub = function (a, b) {
        return new Point(a.x - b.x, a.y - b.y);
      };

      /**
          * Multiply a point by a scalar and return the result as a new Point object.
          * @param {number} s - the scalar
          * @param {!XY} p - any "Point like" object with {x,y}
          * @return {Point} the resulting Point object.
          */
      Point.mul = function (s, p) {
        return new Point(s * p.x, s * p.y);
      };

      /**
          * Perform the cross product on either two points (this produces a scalar)
          * or a point and a scalar (this produces a point).
          * This function requires two parameters, either may be a Point object or a
          * number.
          * @param  {XY|number} a - Point object or scalar.
          * @param  {XY|number} b - Point object or scalar.
          * @return {Point|number} a Point object or a number, depending on the parameters.
          */
      Point.cross = function (a, b) {
        if (typeof a === 'number') {
          if (typeof b === 'number') {
            return a * b;
          } else {
            return new Point(-a * b.y, a * b.x);
          }
        } else {
          if (typeof b === 'number') {
            return new Point(b * a.y, -b * a.x);
          } else {
            return a.x * b.y - a.y * b.x;
          }
        }
      };


      // -----------------------------------------------------------------"Point-Like"
      /*
       * The following functions operate on "Point" or any "Point like" object 
       * with {x,y} (duck typing).
       */

      Point.toString = xy.toString;
      Point.compare = xy.compare;
      Point.cmp = xy.compare; // backward compatibility
      Point.equals = xy.equals;

      /**
                                 * Peform the dot product on two vectors.
                                 * @public
                                 * @param {!XY} a - any "Point like" object with {x,y}
                                 * @param {!XY} b - any "Point like" object with {x,y}
                                 * @return {number} The dot product
                                 */
      Point.dot = function (a, b) {
        return a.x * b.x + a.y * b.y;
      };


      // ---------------------------------------------------------Exports (public API)

      module.exports = Point;

    }, { "./xy": 11 }], 5: [function (require, module, exports) {
      /*
                                                                  * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                                  * http://code.google.com/p/poly2tri/
                                                                  * 
                                                                  * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                                  * https://github.com/r3mi/poly2tri.js
                                                                  * 
                                                                  * All rights reserved.
                                                                  * 
                                                                  * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                                  */

      "use strict";

      /*
                     * Class added in the JavaScript version (was not present in the c++ version)
                     */

      var xy = require('./xy');

      /**
                                 * Custom exception class to indicate invalid Point values
                                 * @constructor
                                 * @public
                                 * @extends Error
                                 * @struct
                                 * @param {string=} message - error message
                                 * @param {Array.<XY>=} points - invalid points
                                 */
      var PointError = function PointError(message, points) {
        this.name = "PointError";
        /**
                                   * Invalid points
                                   * @public
                                   * @type {Array.<XY>}
                                   */
        this.points = points = points || [];
        /**
                                              * Error message
                                              * @public
                                              * @type {string}
                                              */
        this.message = message || "Invalid Points!";
        for (var i = 0; i < points.length; i++) {
          this.message += " " + xy.toString(points[i]);
        }
      };
      PointError.prototype = new Error();
      PointError.prototype.constructor = PointError;


      module.exports = PointError;

    }, { "./xy": 11 }], 6: [function (require, module, exports) {
      (function (global) {
        /*
                           * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                           * http://code.google.com/p/poly2tri/
                           * 
                           * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                           * https://github.com/r3mi/poly2tri.js
                           *
                           * All rights reserved.
                           *
                           * Redistribution and use in source and binary forms, with or without modification,
                           * are permitted provided that the following conditions are met:
                           *
                           * * Redistributions of source code must retain the above copyright notice,
                           *   this list of conditions and the following disclaimer.
                           * * Redistributions in binary form must reproduce the above copyright notice,
                           *   this list of conditions and the following disclaimer in the documentation
                           *   and/or other materials provided with the distribution.
                           * * Neither the name of Poly2Tri nor the names of its contributors may be
                           *   used to endorse or promote products derived from this software without specific
                           *   prior written permission.
                           *
                           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
                           * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
                           * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
                           * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
                           * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                           * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                           * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                           */

        "use strict";

        /**
                       * Public API for poly2tri.js
                       * @module poly2tri
                       */


        /**
                           * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
                           * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
                           * @name poly2tri
                           * @global
                           * @public
                           * @type {module:poly2tri}
                           */
        var previousPoly2tri = global.poly2tri;
        /**
                                                 * For Browser + &lt;script&gt; :
                                                 * reverts the {@linkcode poly2tri} global object to its previous value,
                                                 * and returns a reference to the instance called.
                                                 *
                                                 * @example
                                                 *              var p = poly2tri.noConflict();
                                                 * @public
                                                 * @return {module:poly2tri} instance called
                                                 */
        // (this feature is not automatically provided by browserify).
        exports.noConflict = function () {
          global.poly2tri = previousPoly2tri;
          return exports;
        };

        /**
            * poly2tri library version
            * @public
            * @const {string}
            */
        exports.VERSION = require('../dist/version.json').version;

        /**
                                                                    * Exports the {@linkcode PointError} class.
                                                                    * @public
                                                                    * @typedef {PointError} module:poly2tri.PointError
                                                                    * @function
                                                                    */
        exports.PointError = require('./pointerror');
        /**
                                                       * Exports the {@linkcode Point} class.
                                                       * @public
                                                       * @typedef {Point} module:poly2tri.Point
                                                       * @function
                                                       */
        exports.Point = require('./point');
        /**
                                             * Exports the {@linkcode Triangle} class.
                                             * @public
                                             * @typedef {Triangle} module:poly2tri.Triangle
                                             * @function
                                             */
        exports.Triangle = require('./triangle');
        /**
                                                   * Exports the {@linkcode SweepContext} class.
                                                   * @public
                                                   * @typedef {SweepContext} module:poly2tri.SweepContext
                                                   * @function
                                                   */
        exports.SweepContext = require('./sweepcontext');


        // Backward compatibility
        var sweep = require('./sweep');
        /**
                                         * @function
                                         * @deprecated use {@linkcode SweepContext#triangulate} instead
                                         */
        exports.triangulate = sweep.triangulate;
        /**
                                                  * @deprecated use {@linkcode SweepContext#triangulate} instead
                                                  * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
                                                  */
        exports.sweep = { Triangulate: sweep.triangulate };

      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../dist/version.json": 1, "./point": 4, "./pointerror": 5, "./sweep": 7, "./sweepcontext": 8, "./triangle": 9 }], 7: [function (require, module, exports) {
      /*
                                                                                                                                                                      * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                                                      * http://code.google.com/p/poly2tri/
                                                                                                                                                                      * 
                                                                                                                                                                      * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                                                      * https://github.com/r3mi/poly2tri.js
                                                                                                                                                                      * 
                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                      * 
                                                                                                                                                                      * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                                                                                                                                      */

      /* jshint latedef:nofunc, maxcomplexity:9 */

      "use strict";

      /**
                     * This 'Sweep' module is present in order to keep this JavaScript version
                     * as close as possible to the reference C++ version, even though almost all
                     * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
                     * @module
                     * @private
                     */

      /*
                         * Note
                         * ====
                         * the structure of this JavaScript version of poly2tri intentionally follows
                         * as closely as possible the structure of the reference C++ version, to make it 
                         * easier to keep the 2 versions in sync.
                         */

      var assert = require('./assert');
      var PointError = require('./pointerror');
      var Triangle = require('./triangle');
      var Node = require('./advancingfront').Node;


      // ------------------------------------------------------------------------utils

      var utils = require('./utils');

      /** @const */
      var EPSILON = utils.EPSILON;

      /** @const */
      var Orientation = utils.Orientation;
      /** @const */
      var orient2d = utils.orient2d;
      /** @const */
      var inScanArea = utils.inScanArea;
      /** @const */
      var isAngleObtuse = utils.isAngleObtuse;


      // ------------------------------------------------------------------------Sweep

      /**
       * Triangulate the polygon with holes and Steiner points.
       * Do this AFTER you've added the polyline, holes, and Steiner points
       * @private
       * @param {!SweepContext} tcx - SweepContext object
       */
      function triangulate(tcx) {
        tcx.initTriangulation();
        tcx.createAdvancingFront();
        // Sweep points; build mesh
        sweepPoints(tcx);
        // Clean up
        finalizationPolygon(tcx);
      }

      /**
         * Start sweeping the Y-sorted point set from bottom to top
         * @param {!SweepContext} tcx - SweepContext object
         */
      function sweepPoints(tcx) {
        var i,len = tcx.pointCount();
        for (i = 1; i < len; ++i) {
          var point = tcx.getPoint(i);
          var node = pointEvent(tcx, point);
          var edges = point._p2t_edge_list;
          for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
          }
        }
      }

      /**
         * @param {!SweepContext} tcx - SweepContext object
         */
      function finalizationPolygon(tcx) {
        // Get an Internal triangle to start with
        var t = tcx.front().head().next.triangle;
        var p = tcx.front().head().next.point;
        while (!t.getConstrainedEdgeCW(p)) {
          t = t.neighborCCW(p);
        }

        // Collect interior triangles constrained by edges
        tcx.meshClean(t);
      }

      /**
         * Find closes node to the left of the new point and
         * create a new triangle. If needed new holes and basins
         * will be filled to.
         * @param {!SweepContext} tcx - SweepContext object
         * @param {!XY} point   Point
         */
      function pointEvent(tcx, point) {
        var node = tcx.locateNode(point);
        var new_node = newFrontTriangle(tcx, point, node);

        // Only need to check +epsilon since point never have smaller
        // x value than node due to how we fetch nodes from the front
        if (point.x <= node.point.x + EPSILON) {
          fill(tcx, node);
        }

        //tcx.AddNode(new_node);

        fillAdvancingFront(tcx, new_node);
        return new_node;
      }

      function edgeEventByEdge(tcx, edge, node) {
        tcx.edge_event.constrained_edge = edge;
        tcx.edge_event.right = edge.p.x > edge.q.x;

        if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
          return;
        }

        // For now we will do all needed filling
        // TODO: integrate with flip process might give some better performance
        //       but for now this avoid the issue with cases that needs both flips and fills
        fillEdgeEvent(tcx, edge, node);
        edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
      }

      function edgeEventByPoints(tcx, ep, eq, triangle, point) {
        if (isEdgeSideOfTriangle(triangle, ep, eq)) {
          return;
        }

        var p1 = triangle.pointCCW(point);
        var o1 = orient2d(eq, p1, ep);
        if (o1 === Orientation.COLLINEAR) {
          // TODO integrate here changes from C++ version
          // (C++ repo revision 09880a869095 dated March 8, 2011)
          throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
        }

        var p2 = triangle.pointCW(point);
        var o2 = orient2d(eq, p2, ep);
        if (o2 === Orientation.COLLINEAR) {
          // TODO integrate here changes from C++ version
          // (C++ repo revision 09880a869095 dated March 8, 2011)
          throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
        }

        if (o1 === o2) {
          // Need to decide if we are rotating CW or CCW to get to a triangle
          // that will cross edge
          if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
          } else {
            triangle = triangle.neighborCW(point);
          }
          edgeEventByPoints(tcx, ep, eq, triangle, point);
        } else {
          // This triangle crosses constraint so lets flippin start!
          flipEdgeEvent(tcx, ep, eq, triangle, point);
        }
      }

      function isEdgeSideOfTriangle(triangle, ep, eq) {
        var index = triangle.edgeIndex(ep, eq);
        if (index !== -1) {
          triangle.markConstrainedEdgeByIndex(index);
          var t = triangle.getNeighbor(index);
          if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
          }
          return true;
        }
        return false;
      }

      /**
         * Creates a new front triangle and legalize it
         * @param {!SweepContext} tcx - SweepContext object
         */
      function newFrontTriangle(tcx, point, node) {
        var triangle = new Triangle(point, node.point, node.next.point);

        triangle.markNeighbor(node.triangle);
        tcx.addToMap(triangle);

        var new_node = new Node(point);
        new_node.next = node.next;
        new_node.prev = node;
        node.next.prev = new_node;
        node.next = new_node;

        if (!legalize(tcx, triangle)) {
          tcx.mapTriangleToNodes(triangle);
        }

        return new_node;
      }

      /**
         * Adds a triangle to the advancing front to fill a hole.
         * @param {!SweepContext} tcx - SweepContext object
         * @param node - middle node, that is the bottom of the hole
         */
      function fill(tcx, node) {
        var triangle = new Triangle(node.prev.point, node.point, node.next.point);

        // TODO: should copy the constrained_edge value from neighbor triangles
        //       for now constrained_edge values are copied during the legalize
        triangle.markNeighbor(node.prev.triangle);
        triangle.markNeighbor(node.triangle);

        tcx.addToMap(triangle);

        // Update the advancing front
        node.prev.next = node.next;
        node.next.prev = node.prev;


        // If it was legalized the triangle has already been mapped
        if (!legalize(tcx, triangle)) {
          tcx.mapTriangleToNodes(triangle);
        }

        //tcx.removeNode(node);
      }

      /**
         * Fills holes in the Advancing Front
         * @param {!SweepContext} tcx - SweepContext object
         */
      function fillAdvancingFront(tcx, n) {
        // Fill right holes
        var node = n.next;
        while (node.next) {
          // TODO integrate here changes from C++ version
          // (C++ repo revision acf81f1f1764 dated April 7, 2012)
          if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
          }
          fill(tcx, node);
          node = node.next;
        }

        // Fill left holes
        node = n.prev;
        while (node.prev) {
          // TODO integrate here changes from C++ version
          // (C++ repo revision acf81f1f1764 dated April 7, 2012)
          if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
          }
          fill(tcx, node);
          node = node.prev;
        }

        // Fill right basins
        if (n.next && n.next.next) {
          if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
          }
        }
      }

      /**
         * The basin angle is decided against the horizontal line [1,0].
         * @param {Node} node
         * @return {boolean} true if angle < 3*π/4
         */
      function isBasinAngleRight(node) {
        var ax = node.point.x - node.next.next.point.x;
        var ay = node.point.y - node.next.next.point.y;
        assert(ay >= 0, "unordered y");
        return ax >= 0 || Math.abs(ax) < ay;
      }

      /**
         * Returns true if triangle was legalized
         * @param {!SweepContext} tcx - SweepContext object
         * @return {boolean}
         */
      function legalize(tcx, t) {
        // To legalize a triangle we start by finding if any of the three edges
        // violate the Delaunay condition
        for (var i = 0; i < 3; ++i) {
          if (t.delaunay_edge[i]) {
            continue;
          }
          var ot = t.getNeighbor(i);
          if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
              t.constrained_edge[i] = ot.constrained_edge[oi];
              continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
              // Lets mark this shared edge as Delaunay
              t.delaunay_edge[i] = true;
              ot.delaunay_edge[oi] = true;

              // Lets rotate shared edge one vertex CW to legalize it
              rotateTrianglePair(t, p, ot, op);

              // We now got one valid Delaunay Edge shared by two triangles
              // This gives us 4 new edges to check for Delaunay

              // Make sure that triangle to node mapping is done only one time for a specific triangle
              var not_legalized = !legalize(tcx, t);
              if (not_legalized) {
                tcx.mapTriangleToNodes(t);
              }

              not_legalized = !legalize(tcx, ot);
              if (not_legalized) {
                tcx.mapTriangleToNodes(ot);
              }
              // Reset the Delaunay edges, since they only are valid Delaunay edges
              // until we add a new triangle or point.
              // XXX: need to think about this. Can these edges be tried after we
              //      return to previous recursive level?
              t.delaunay_edge[i] = false;
              ot.delaunay_edge[oi] = false;

              // If triangle have been legalized no need to check the other edges since
              // the recursive legalization will handles those so we can end here.
              return true;
            }
          }
        }
        return false;
      }

      /**
         * <b>Requirement</b>:<br>
         * 1. a,b and c form a triangle.<br>
         * 2. a and d is know to be on opposite side of bc<br>
         * <pre>
         *                a
         *                +
         *               / \
         *              /   \
         *            b/     \c
         *            +-------+
         *           /    d    \
         *          /           \
         * </pre>
         * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
         *  a,b and c<br>
         *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
         *  This preknowledge gives us a way to optimize the incircle test
         * @param pa - triangle point, opposite d
         * @param pb - triangle point
         * @param pc - triangle point
         * @param pd - point opposite a
         * @return {boolean} true if d is inside circle, false if on circle edge
         */
      function inCircle(pa, pb, pc, pd) {
        var adx = pa.x - pd.x;
        var ady = pa.y - pd.y;
        var bdx = pb.x - pd.x;
        var bdy = pb.y - pd.y;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;
        if (oabd <= 0) {
          return false;
        }

        var cdx = pc.x - pd.x;
        var cdy = pc.y - pd.y;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;
        if (ocad <= 0) {
          return false;
        }

        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;

        var alift = adx * adx + ady * ady;
        var blift = bdx * bdx + bdy * bdy;
        var clift = cdx * cdx + cdy * cdy;

        var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
        return det > 0;
      }

      /**
         * Rotates a triangle pair one vertex CW
         *<pre>
         *       n2                    n2
         *  P +-----+             P +-----+
         *    | t  /|               |\  t |
         *    |   / |               | \   |
         *  n1|  /  |n3           n1|  \  |n3
         *    | /   |    after CW   |   \ |
         *    |/ oT |               | oT \|
         *    +-----+ oP            +-----+
         *       n4                    n4
         * </pre>
         */
      function rotateTrianglePair(t, p, ot, op) {
        var n1, n2, n3, n4;
        n1 = t.neighborCCW(p);
        n2 = t.neighborCW(p);
        n3 = ot.neighborCCW(op);
        n4 = ot.neighborCW(op);

        var ce1, ce2, ce3, ce4;
        ce1 = t.getConstrainedEdgeCCW(p);
        ce2 = t.getConstrainedEdgeCW(p);
        ce3 = ot.getConstrainedEdgeCCW(op);
        ce4 = ot.getConstrainedEdgeCW(op);

        var de1, de2, de3, de4;
        de1 = t.getDelaunayEdgeCCW(p);
        de2 = t.getDelaunayEdgeCW(p);
        de3 = ot.getDelaunayEdgeCCW(op);
        de4 = ot.getDelaunayEdgeCW(op);

        t.legalize(p, op);
        ot.legalize(op, p);

        // Remap delaunay_edge
        ot.setDelaunayEdgeCCW(p, de1);
        t.setDelaunayEdgeCW(p, de2);
        t.setDelaunayEdgeCCW(op, de3);
        ot.setDelaunayEdgeCW(op, de4);

        // Remap constrained_edge
        ot.setConstrainedEdgeCCW(p, ce1);
        t.setConstrainedEdgeCW(p, ce2);
        t.setConstrainedEdgeCCW(op, ce3);
        ot.setConstrainedEdgeCW(op, ce4);

        // Remap neighbors
        // XXX: might optimize the markNeighbor by keeping track of
        //      what side should be assigned to what neighbor after the
        //      rotation. Now mark neighbor does lots of testing to find
        //      the right side.
        t.clearNeighbors();
        ot.clearNeighbors();
        if (n1) {
          ot.markNeighbor(n1);
        }
        if (n2) {
          t.markNeighbor(n2);
        }
        if (n3) {
          t.markNeighbor(n3);
        }
        if (n4) {
          ot.markNeighbor(n4);
        }
        t.markNeighbor(ot);
      }

      /**
         * Fills a basin that has formed on the Advancing Front to the right
         * of given node.<br>
         * First we decide a left,bottom and right node that forms the
         * boundaries of the basin. Then we do a reqursive fill.
         *
         * @param {!SweepContext} tcx - SweepContext object
         * @param node - starting node, this or next node will be left node
         */
      function fillBasin(tcx, node) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
          tcx.basin.left_node = node.next.next;
        } else {
          tcx.basin.left_node = node.next;
        }

        // Find the bottom and right node
        tcx.basin.bottom_node = tcx.basin.left_node;
        while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
          tcx.basin.bottom_node = tcx.basin.bottom_node.next;
        }
        if (tcx.basin.bottom_node === tcx.basin.left_node) {
          // No valid basin
          return;
        }

        tcx.basin.right_node = tcx.basin.bottom_node;
        while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
          tcx.basin.right_node = tcx.basin.right_node.next;
        }
        if (tcx.basin.right_node === tcx.basin.bottom_node) {
          // No valid basins
          return;
        }

        tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
        tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

        fillBasinReq(tcx, tcx.basin.bottom_node);
      }

      /**
         * Recursive algorithm to fill a Basin with triangles
         *
         * @param {!SweepContext} tcx - SweepContext object
         * @param node - bottom_node
         */
      function fillBasinReq(tcx, node) {
        // if shallow stop filling
        if (isShallow(tcx, node)) {
          return;
        }

        fill(tcx, node);

        var o;
        if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
          return;
        } else if (node.prev === tcx.basin.left_node) {
          o = orient2d(node.point, node.next.point, node.next.next.point);
          if (o === Orientation.CW) {
            return;
          }
          node = node.next;
        } else if (node.next === tcx.basin.right_node) {
          o = orient2d(node.point, node.prev.point, node.prev.prev.point);
          if (o === Orientation.CCW) {
            return;
          }
          node = node.prev;
        } else {
          // Continue with the neighbor node with lowest Y value
          if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
          } else {
            node = node.next;
          }
        }

        fillBasinReq(tcx, node);
      }

      function isShallow(tcx, node) {
        var height;
        if (tcx.basin.left_highest) {
          height = tcx.basin.left_node.point.y - node.point.y;
        } else {
          height = tcx.basin.right_node.point.y - node.point.y;
        }

        // if shallow stop filling
        if (tcx.basin.width > height) {
          return true;
        }
        return false;
      }

      function fillEdgeEvent(tcx, edge, node) {
        if (tcx.edge_event.right) {
          fillRightAboveEdgeEvent(tcx, edge, node);
        } else {
          fillLeftAboveEdgeEvent(tcx, edge, node);
        }
      }

      function fillRightAboveEdgeEvent(tcx, edge, node) {
        while (node.next.point.x < edge.p.x) {
          // Check if next node is below the edge
          if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
          } else {
            node = node.next;
          }
        }
      }

      function fillRightBelowEdgeEvent(tcx, edge, node) {
        if (node.point.x < edge.p.x) {
          if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
          } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
          }
        }
      }

      function fillRightConcaveEdgeEvent(tcx, edge, node) {
        fill(tcx, node.next);
        if (node.next.point !== edge.p) {
          // Next above or below edge?
          if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
              // Next is concave
              fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
              // Next is convex
              /* jshint noempty:false */
            }
          }
        }
      }

      function fillRightConvexEdgeEvent(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
          // Concave
          fillRightConcaveEdgeEvent(tcx, edge, node.next);
        } else {
          // Convex
          // Next above or below edge?
          if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
          } else {
            // Above
            /* jshint noempty:false */
          }
        }
      }

      function fillLeftAboveEdgeEvent(tcx, edge, node) {
        while (node.prev.point.x > edge.p.x) {
          // Check if next node is below the edge
          if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
          } else {
            node = node.prev;
          }
        }
      }

      function fillLeftBelowEdgeEvent(tcx, edge, node) {
        if (node.point.x > edge.p.x) {
          if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
          } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
          }
        }
      }

      function fillLeftConvexEdgeEvent(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
          // Concave
          fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
        } else {
          // Convex
          // Next above or below edge?
          if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
          } else {
            // Above
            /* jshint noempty:false */
          }
        }
      }

      function fillLeftConcaveEdgeEvent(tcx, edge, node) {
        fill(tcx, node.prev);
        if (node.prev.point !== edge.p) {
          // Next above or below edge?
          if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
              // Next is concave
              fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
              // Next is convex
              /* jshint noempty:false */
            }
          }
        }
      }

      function flipEdgeEvent(tcx, ep, eq, t, p) {
        var ot = t.neighborAcross(p);
        assert(ot, "FLIP failed due to missing triangle!");

        var op = ot.oppositePoint(t, p);

        // Additional check from Java version (see issue #88)
        if (t.getConstrainedEdgeAcross(p)) {
          var index = t.index(p);
          throw new PointError("poly2tri Intersecting Constraints",
          [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
        }

        if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
          // Lets rotate shared edge one vertex CW
          rotateTrianglePair(t, p, ot, op);
          tcx.mapTriangleToNodes(t);
          tcx.mapTriangleToNodes(ot);

          // XXX: in the original C++ code for the next 2 lines, we are
          // comparing point values (and not pointers). In this JavaScript
          // code, we are comparing point references (pointers). This works
          // because we can't have 2 different points with the same values.
          // But to be really equivalent, we should use "Point.equals" here.
          if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
              t.markConstrainedEdgeByPoints(ep, eq);
              ot.markConstrainedEdgeByPoints(ep, eq);
              legalize(tcx, t);
              legalize(tcx, ot);
            } else {
              // XXX: I think one of the triangles should be legalized here?
              /* jshint noempty:false */
            }
          } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
          }
        } else {
          var newP = nextFlipPoint(ep, eq, ot, op);
          flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
          edgeEventByPoints(tcx, ep, eq, t, p);
        }
      }

      /**
         * After a flip we have two triangles and know that only one will still be
         * intersecting the edge. So decide which to contiune with and legalize the other
         *
         * @param {!SweepContext} tcx - SweepContext object
         * @param o - should be the result of an orient2d( eq, op, ep )
         * @param t - triangle 1
         * @param ot - triangle 2
         * @param p - a point shared by both triangles
         * @param op - another point shared by both triangles
         * @return returns the triangle still intersecting the edge
         */
      function nextFlipTriangle(tcx, o, t, ot, p, op) {
        var edge_index;
        if (o === Orientation.CCW) {
          // ot is not crossing edge after flip
          edge_index = ot.edgeIndex(p, op);
          ot.delaunay_edge[edge_index] = true;
          legalize(tcx, ot);
          ot.clearDelaunayEdges();
          return t;
        }

        // t is not crossing edge after flip
        edge_index = t.edgeIndex(p, op);

        t.delaunay_edge[edge_index] = true;
        legalize(tcx, t);
        t.clearDelaunayEdges();
        return ot;
      }

      /**
         * When we need to traverse from one triangle to the next we need
         * the point in current triangle that is the opposite point to the next
         * triangle.
         */
      function nextFlipPoint(ep, eq, ot, op) {
        var o2d = orient2d(eq, op, ep);
        if (o2d === Orientation.CW) {
          // Right
          return ot.pointCCW(op);
        } else if (o2d === Orientation.CCW) {
          // Left
          return ot.pointCW(op);
        } else {
          throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
        }
      }

      /**
         * Scan part of the FlipScan algorithm<br>
         * When a triangle pair isn't flippable we will scan for the next
         * point that is inside the flip triangle scan area. When found
         * we generate a new flipEdgeEvent
         *
         * @param {!SweepContext} tcx - SweepContext object
         * @param ep - last point on the edge we are traversing
         * @param eq - first point on the edge we are traversing
         * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
         * @param t
         * @param p
         */
      function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
        var ot = t.neighborAcross(p);
        assert(ot, "FLIP failed due to missing triangle");

        var op = ot.oppositePoint(t, p);

        if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
          // flip with new edge op.eq
          flipEdgeEvent(tcx, eq, op, ot, op);
        } else {
          var newP = nextFlipPoint(ep, eq, ot, op);
          flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
        }
      }


      // ----------------------------------------------------------------------Exports

      exports.triangulate = triangulate;

    }, { "./advancingfront": 2, "./assert": 3, "./pointerror": 5, "./triangle": 9, "./utils": 10 }], 8: [function (require, module, exports) {
      /*
                                                                                                                                               * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                               * http://code.google.com/p/poly2tri/
                                                                                                                                               * 
                                                                                                                                               * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                               * https://github.com/r3mi/poly2tri.js
                                                                                                                                               * 
                                                                                                                                               * All rights reserved.
                                                                                                                                               * 
                                                                                                                                               * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                                                                                                               */

      /* jshint maxcomplexity:6 */

      "use strict";


      /*
                     * Note
                     * ====
                     * the structure of this JavaScript version of poly2tri intentionally follows
                     * as closely as possible the structure of the reference C++ version, to make it 
                     * easier to keep the 2 versions in sync.
                     */

      var PointError = require('./pointerror');
      var Point = require('./point');
      var Triangle = require('./triangle');
      var sweep = require('./sweep');
      var AdvancingFront = require('./advancingfront');
      var Node = AdvancingFront.Node;


      // ------------------------------------------------------------------------utils

      /**
       * Initial triangle factor, seed triangle will extend 30% of
       * PointSet width to both left and right.
       * @private
       * @const
       */
      var kAlpha = 0.3;


      // -------------------------------------------------------------------------Edge
      /**
       * Represents a simple polygon's edge
       * @constructor
       * @struct
       * @private
       * @param {Point} p1
       * @param {Point} p2
       * @throw {PointError} if p1 is same as p2
       */
      var Edge = function Edge(p1, p2) {
        this.p = p1;
        this.q = p2;

        if (p1.y > p2.y) {
          this.q = p1;
          this.p = p2;
        } else if (p1.y === p2.y) {
          if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
          } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
          }
        }

        if (!this.q._p2t_edge_list) {
          this.q._p2t_edge_list = [];
        }
        this.q._p2t_edge_list.push(this);
      };


      // ------------------------------------------------------------------------Basin
      /**
       * @constructor
       * @struct
       * @private
       */
      var Basin = function Basin() {
        /** @type {Node} */
        this.left_node = null;
        /** @type {Node} */
        this.bottom_node = null;
        /** @type {Node} */
        this.right_node = null;
        /** @type {number} */
        this.width = 0.0;
        /** @type {boolean} */
        this.left_highest = false;
      };

      Basin.prototype.clear = function () {
        this.left_node = null;
        this.bottom_node = null;
        this.right_node = null;
        this.width = 0.0;
        this.left_highest = false;
      };

      // --------------------------------------------------------------------EdgeEvent
      /**
       * @constructor
       * @struct
       * @private
       */
      var EdgeEvent = function EdgeEvent() {
        /** @type {Edge} */
        this.constrained_edge = null;
        /** @type {boolean} */
        this.right = false;
      };

      // ----------------------------------------------------SweepContext (public API)
      /**
       * SweepContext constructor option
       * @typedef {Object} SweepContextOptions
       * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
       *                  (contour, holes). Points inside arrays are never copied.
       *                  Default is <code>false</code> : keep a reference to the array arguments,
       *                  who will be modified in place.
       */
      /**
           * Constructor for the triangulation context.
           * It accepts a simple polyline (with non repeating points), 
           * which defines the constrained edges.
           *
           * @example
           *          var contour = [
           *              new poly2tri.Point(100, 100),
           *              new poly2tri.Point(100, 300),
           *              new poly2tri.Point(300, 300),
           *              new poly2tri.Point(300, 100)
           *          ];
           *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
           * @example
           *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
           *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
           * @constructor
           * @public
           * @struct
           * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
           *          or any "Point like" custom class with <code>{x, y}</code> attributes.
           * @param {SweepContextOptions=} options - constructor options
           */
      var SweepContext = function SweepContext(contour, options) {
        options = options || {};
        this.triangles_ = [];
        this.map_ = [];
        this.points_ = options.cloneArrays ? contour.slice(0) : contour;
        this.edge_list = [];

        // Bounding box of all points. Computed at the start of the triangulation, 
        // it is stored in case it is needed by the caller.
        this.pmin_ = this.pmax_ = null;

        /**
                                         * Advancing front
                                         * @private
                                         * @type {AdvancingFront}
                                         */
        this.front_ = null;

        /**
                             * head point used with advancing front
                             * @private
                             * @type {Point}
                             */
        this.head_ = null;

        /**
                            * tail point used with advancing front
                            * @private
                            * @type {Point}
                            */
        this.tail_ = null;

        /**
                            * @private
                            * @type {Node}
                            */
        this.af_head_ = null;
        /**
                               * @private
                               * @type {Node}
                               */
        this.af_middle_ = null;
        /**
                                 * @private
                                 * @type {Node}
                                 */
        this.af_tail_ = null;

        this.basin = new Basin();
        this.edge_event = new EdgeEvent();

        this.initEdges(this.points_);
      };


      /**
          * Add a hole to the constraints
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      var hole = [
          *          new poly2tri.Point(200, 200),
          *          new poly2tri.Point(200, 250),
          *          new poly2tri.Point(250, 250)
          *      ];
          *      swctx.addHole(hole);
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
          * @public
          * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
          */
      SweepContext.prototype.addHole = function (polyline) {
        this.initEdges(polyline);
        var i,len = polyline.length;
        for (i = 0; i < len; i++) {
          this.points_.push(polyline[i]);
        }
        return this; // for chaining
      };

      /**
          * For backward compatibility
          * @function
          * @deprecated use {@linkcode SweepContext#addHole} instead
          */
      SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


      /**
                                                                        * Add several holes to the constraints
                                                                        * @example
                                                                        *      var swctx = new poly2tri.SweepContext(contour);
                                                                        *      var holes = [
                                                                        *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
                                                                        *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
                                                                        *      ];
                                                                        *      swctx.addHoles(holes);
                                                                        * @example
                                                                        *      var swctx = new poly2tri.SweepContext(contour);
                                                                        *      var holes = [
                                                                        *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
                                                                        *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
                                                                        *      ];
                                                                        *      swctx.addHoles(holes);
                                                                        * @public
                                                                        * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
                                                                        */
      // Method added in the JavaScript version (was not present in the c++ version)
      SweepContext.prototype.addHoles = function (holes) {
        var i,len = holes.length;
        for (i = 0; i < len; i++) {
          this.initEdges(holes[i]);
        }
        this.points_ = this.points_.concat.apply(this.points_, holes);
        return this; // for chaining
      };


      /**
          * Add a Steiner point to the constraints
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      var point = new poly2tri.Point(150, 150);
          *      swctx.addPoint(point);
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.addPoint({x:150, y:150});
          * @public
          * @param {XY} point - any "Point like" object with {x,y}
          */
      SweepContext.prototype.addPoint = function (point) {
        this.points_.push(point);
        return this; // for chaining
      };

      /**
          * For backward compatibility
          * @function
          * @deprecated use {@linkcode SweepContext#addPoint} instead
          */
      SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


      /**
                                                                          * Add several Steiner points to the constraints
                                                                          * @example
                                                                          *      var swctx = new poly2tri.SweepContext(contour);
                                                                          *      var points = [
                                                                          *          new poly2tri.Point(150, 150),
                                                                          *          new poly2tri.Point(200, 250),
                                                                          *          new poly2tri.Point(250, 250)
                                                                          *      ];
                                                                          *      swctx.addPoints(points);
                                                                          * @example
                                                                          *      var swctx = new poly2tri.SweepContext(contour);
                                                                          *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
                                                                          * @public
                                                                          * @param {Array.<XY>} points - array of "Point like" object with {x,y}
                                                                          */
      // Method added in the JavaScript version (was not present in the c++ version)
      SweepContext.prototype.addPoints = function (points) {
        this.points_ = this.points_.concat(points);
        return this; // for chaining
      };


      /**
          * Triangulate the polygon with holes and Steiner points.
          * Do this AFTER you've added the polyline, holes, and Steiner points
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.triangulate();
          *      var triangles = swctx.getTriangles();
          * @public
          */
      // Shortcut method for sweep.triangulate(SweepContext).
      // Method added in the JavaScript version (was not present in the c++ version)
      SweepContext.prototype.triangulate = function () {
        sweep.triangulate(this);
        return this; // for chaining
      };


      /**
          * Get the bounding box of the provided constraints (contour, holes and 
          * Steinter points). Warning : these values are not available if the triangulation 
          * has not been done yet.
          * @public
          * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
          */
      // Method added in the JavaScript version (was not present in the c++ version)
      SweepContext.prototype.getBoundingBox = function () {
        return { min: this.pmin_, max: this.pmax_ };
      };

      /**
          * Get result of triangulation.
          * The output triangles have vertices which are references
          * to the initial input points (not copies): any custom fields in the
          * initial points can be retrieved in the output triangles.
          * @example
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.triangulate();
          *      var triangles = swctx.getTriangles();
          * @example
          *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.triangulate();
          *      var triangles = swctx.getTriangles();
          *      typeof triangles[0].getPoint(0).id
          *      // → "number"
          * @public
          * @returns {array<Triangle>}   array of triangles
          */
      SweepContext.prototype.getTriangles = function () {
        return this.triangles_;
      };

      /**
          * For backward compatibility
          * @function
          * @deprecated use {@linkcode SweepContext#getTriangles} instead
          */
      SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


      // ---------------------------------------------------SweepContext (private API)

      /** @private */
      SweepContext.prototype.front = function () {
        return this.front_;
      };

      /** @private */
      SweepContext.prototype.pointCount = function () {
        return this.points_.length;
      };

      /** @private */
      SweepContext.prototype.head = function () {
        return this.head_;
      };

      /** @private */
      SweepContext.prototype.setHead = function (p1) {
        this.head_ = p1;
      };

      /** @private */
      SweepContext.prototype.tail = function () {
        return this.tail_;
      };

      /** @private */
      SweepContext.prototype.setTail = function (p1) {
        this.tail_ = p1;
      };

      /** @private */
      SweepContext.prototype.getMap = function () {
        return this.map_;
      };

      /** @private */
      SweepContext.prototype.initTriangulation = function () {
        var xmax = this.points_[0].x;
        var xmin = this.points_[0].x;
        var ymax = this.points_[0].y;
        var ymin = this.points_[0].y;

        // Calculate bounds
        var i,len = this.points_.length;
        for (i = 1; i < len; i++) {
          var p = this.points_[i];
          /* jshint expr:true */
          p.x > xmax && (xmax = p.x);
          p.x < xmin && (xmin = p.x);
          p.y > ymax && (ymax = p.y);
          p.y < ymin && (ymin = p.y);
        }
        this.pmin_ = new Point(xmin, ymin);
        this.pmax_ = new Point(xmax, ymax);

        var dx = kAlpha * (xmax - xmin);
        var dy = kAlpha * (ymax - ymin);
        this.head_ = new Point(xmax + dx, ymin - dy);
        this.tail_ = new Point(xmin - dx, ymin - dy);

        // Sort points along y-axis
        this.points_.sort(Point.compare);
      };

      /** @private */
      SweepContext.prototype.initEdges = function (polyline, isOpen) {
        var i,len = polyline.length,iEnd = isOpen ? polyline.length - 1 : polyline.length;
        for (i = 0; i < iEnd; ++i) {
          this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
        }
      };

      /** @private */
      SweepContext.prototype.getPoint = function (index) {
        return this.points_[index];
      };

      /** @private */
      SweepContext.prototype.addToMap = function (triangle) {
        this.map_.push(triangle);
      };

      /** @private */
      SweepContext.prototype.locateNode = function (point) {
        return this.front_.locateNode(point.x);
      };

      /** @private */
      SweepContext.prototype.createAdvancingFront = function () {
        var head;
        var middle;
        var tail;
        // Initial triangle
        var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

        this.map_.push(triangle);

        head = new Node(triangle.getPoint(1), triangle);
        middle = new Node(triangle.getPoint(0), triangle);
        tail = new Node(triangle.getPoint(2));

        this.front_ = new AdvancingFront(head, tail);

        head.next = middle;
        middle.next = tail;
        middle.prev = head;
        tail.prev = middle;
      };

      /** @private */
      SweepContext.prototype.removeNode = function (node) {
        // do nothing
        /* jshint unused:false */
      };

      /** @private */
      SweepContext.prototype.mapTriangleToNodes = function (t) {
        for (var i = 0; i < 3; ++i) {
          if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
              n.triangle = t;
            }
          }
        }
      };

      /** @private */
      SweepContext.prototype.removeFromMap = function (triangle) {
        var i,map = this.map_,len = map.length;
        for (i = 0; i < len; i++) {
          if (map[i] === triangle) {
            map.splice(i, 1);
            break;
          }
        }
      };

      /**
          * Do a depth first traversal to collect triangles
          * @private
          * @param {Triangle} triangle start
          */
      SweepContext.prototype.meshClean = function (triangle) {
        // New implementation avoids recursive calls and use a loop instead.
        // Cf. issues # 57, 65 and 69.
        var triangles = [triangle],t,i;
        /* jshint boss:true */
        while (t = triangles.pop()) {
          if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
              if (!t.constrained_edge[i]) {
                triangles.push(t.getNeighbor(i));
              }
            }
          }
        }
      };

      // ----------------------------------------------------------------------Exports

      module.exports = SweepContext;

    }, { "./advancingfront": 2, "./point": 4, "./pointerror": 5, "./sweep": 7, "./triangle": 9 }], 9: [function (require, module, exports) {
      /*
                                                                                                                                             * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                             * http://code.google.com/p/poly2tri/
                                                                                                                                             * 
                                                                                                                                             * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                                                                                                             * https://github.com/r3mi/poly2tri.js
                                                                                                                                             *
                                                                                                                                             * All rights reserved.
                                                                                                                                             * 
                                                                                                                                             * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                                                                                                             */

      /* jshint maxcomplexity:10 */

      "use strict";


      /*
                     * Note
                     * ====
                     * the structure of this JavaScript version of poly2tri intentionally follows
                     * as closely as possible the structure of the reference C++ version, to make it 
                     * easier to keep the 2 versions in sync.
                     */

      var xy = require("./xy");


      // ---------------------------------------------------------------------Triangle
      /**
       * Triangle class.<br>
       * Triangle-based data structures are known to have better performance than
       * quad-edge structures.
       * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
       * Delaunay Triangulator", "Triangulations in CGAL"
       *
       * @constructor
       * @struct
       * @param {!XY} pa  point object with {x,y}
       * @param {!XY} pb  point object with {x,y}
       * @param {!XY} pc  point object with {x,y}
       */
      var Triangle = function Triangle(a, b, c) {
        /**
                                                  * Triangle points
                                                  * @private
                                                  * @type {Array.<XY>}
                                                  */
        this.points_ = [a, b, c];

        /**
                                   * Neighbor list
                                   * @private
                                   * @type {Array.<Triangle>}
                                   */
        this.neighbors_ = [null, null, null];

        /**
                                               * Has this triangle been marked as an interior triangle?
                                               * @private
                                               * @type {boolean}
                                               */
        this.interior_ = false;

        /**
                                 * Flags to determine if an edge is a Constrained edge
                                 * @private
                                 * @type {Array.<boolean>}
                                 */
        this.constrained_edge = [false, false, false];

        /**
                                                        * Flags to determine if an edge is a Delauney edge
                                                        * @private
                                                        * @type {Array.<boolean>}
                                                        */
        this.delaunay_edge = [false, false, false];
      };

      var p2s = xy.toString;
      /**
                              * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
                              * @public
                              * @return {string}
                              */
      Triangle.prototype.toString = function () {
        return "[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]";
      };

      /**
          * Get one vertice of the triangle.
          * The output triangles of a triangulation have vertices which are references
          * to the initial input points (not copies): any custom fields in the
          * initial points can be retrieved in the output triangles.
          * @example
          *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
          *      var swctx = new poly2tri.SweepContext(contour);
          *      swctx.triangulate();
          *      var triangles = swctx.getTriangles();
          *      typeof triangles[0].getPoint(0).id
          *      // → "number"
          * @param {number} index - vertice index: 0, 1 or 2
          * @public
          * @returns {XY}
          */
      Triangle.prototype.getPoint = function (index) {
        return this.points_[index];
      };

      /**
          * For backward compatibility
          * @function
          * @deprecated use {@linkcode Triangle#getPoint} instead
          */
      Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

      /**
                                                                  * Get all 3 vertices of the triangle as an array
                                                                  * @public
                                                                  * @return {Array.<XY>}
                                                                  */
      // Method added in the JavaScript version (was not present in the c++ version)
      Triangle.prototype.getPoints = function () {
        return this.points_;
      };

      /**
          * @private
          * @param {number} index
          * @returns {?Triangle}
          */
      Triangle.prototype.getNeighbor = function (index) {
        return this.neighbors_[index];
      };

      /**
          * Test if this Triangle contains the Point object given as parameter as one of its vertices.
          * Only point references are compared, not values.
          * @public
          * @param {XY} point - point object with {x,y}
          * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
          *         <code>false</code> otherwise.
          */
      Triangle.prototype.containsPoint = function (point) {
        var points = this.points_;
        // Here we are comparing point references, not values
        return point === points[0] || point === points[1] || point === points[2];
      };

      /**
          * Test if this Triangle contains the Edge object given as parameter as its
          * bounding edges. Only point references are compared, not values.
          * @private
          * @param {Edge} edge
          * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
          *         edges, <code>false</code> otherwise.
          */
      Triangle.prototype.containsEdge = function (edge) {
        return this.containsPoint(edge.p) && this.containsPoint(edge.q);
      };

      /**
          * Test if this Triangle contains the two Point objects given as parameters among its vertices.
          * Only point references are compared, not values.
          * @param {XY} p1 - point object with {x,y}
          * @param {XY} p2 - point object with {x,y}
          * @return {boolean}
          */
      Triangle.prototype.containsPoints = function (p1, p2) {
        return this.containsPoint(p1) && this.containsPoint(p2);
      };

      /**
          * Has this triangle been marked as an interior triangle?
          * @returns {boolean}
          */
      Triangle.prototype.isInterior = function () {
        return this.interior_;
      };

      /**
          * Mark this triangle as an interior triangle
          * @private
          * @param {boolean} interior
          * @returns {Triangle} this
          */
      Triangle.prototype.setInterior = function (interior) {
        this.interior_ = interior;
        return this;
      };

      /**
          * Update neighbor pointers.
          * @private
          * @param {XY} p1 - point object with {x,y}
          * @param {XY} p2 - point object with {x,y}
          * @param {Triangle} t Triangle object.
          * @throws {Error} if can't find objects
          */
      Triangle.prototype.markNeighborPointers = function (p1, p2, t) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p1 === points[2] && p2 === points[1] || p1 === points[1] && p2 === points[2]) {
          this.neighbors_[0] = t;
        } else if (p1 === points[0] && p2 === points[2] || p1 === points[2] && p2 === points[0]) {
          this.neighbors_[1] = t;
        } else if (p1 === points[0] && p2 === points[1] || p1 === points[1] && p2 === points[0]) {
          this.neighbors_[2] = t;
        } else {
          throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
        }
      };

      /**
          * Exhaustive search to update neighbor pointers
          * @private
          * @param {!Triangle} t
          */
      Triangle.prototype.markNeighbor = function (t) {
        var points = this.points_;
        if (t.containsPoints(points[1], points[2])) {
          this.neighbors_[0] = t;
          t.markNeighborPointers(points[1], points[2], this);
        } else if (t.containsPoints(points[0], points[2])) {
          this.neighbors_[1] = t;
          t.markNeighborPointers(points[0], points[2], this);
        } else if (t.containsPoints(points[0], points[1])) {
          this.neighbors_[2] = t;
          t.markNeighborPointers(points[0], points[1], this);
        }
      };


      Triangle.prototype.clearNeighbors = function () {
        this.neighbors_[0] = null;
        this.neighbors_[1] = null;
        this.neighbors_[2] = null;
      };

      Triangle.prototype.clearDelaunayEdges = function () {
        this.delaunay_edge[0] = false;
        this.delaunay_edge[1] = false;
        this.delaunay_edge[2] = false;
      };

      /**
          * Returns the point clockwise to the given point.
          * @private
          * @param {XY} p - point object with {x,y}
          */
      Triangle.prototype.pointCW = function (p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
          return points[2];
        } else if (p === points[1]) {
          return points[0];
        } else if (p === points[2]) {
          return points[1];
        } else {
          return null;
        }
      };

      /**
          * Returns the point counter-clockwise to the given point.
          * @private
          * @param {XY} p - point object with {x,y}
          */
      Triangle.prototype.pointCCW = function (p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
          return points[1];
        } else if (p === points[1]) {
          return points[2];
        } else if (p === points[2]) {
          return points[0];
        } else {
          return null;
        }
      };

      /**
          * Returns the neighbor clockwise to given point.
          * @private
          * @param {XY} p - point object with {x,y}
          */
      Triangle.prototype.neighborCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.neighbors_[1];
        } else if (p === this.points_[1]) {
          return this.neighbors_[2];
        } else {
          return this.neighbors_[0];
        }
      };

      /**
          * Returns the neighbor counter-clockwise to given point.
          * @private
          * @param {XY} p - point object with {x,y}
          */
      Triangle.prototype.neighborCCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.neighbors_[2];
        } else if (p === this.points_[1]) {
          return this.neighbors_[0];
        } else {
          return this.neighbors_[1];
        }
      };

      Triangle.prototype.getConstrainedEdgeCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.constrained_edge[1];
        } else if (p === this.points_[1]) {
          return this.constrained_edge[2];
        } else {
          return this.constrained_edge[0];
        }
      };

      Triangle.prototype.getConstrainedEdgeCCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.constrained_edge[2];
        } else if (p === this.points_[1]) {
          return this.constrained_edge[0];
        } else {
          return this.constrained_edge[1];
        }
      };

      // Additional check from Java version (see issue #88)
      Triangle.prototype.getConstrainedEdgeAcross = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.constrained_edge[0];
        } else if (p === this.points_[1]) {
          return this.constrained_edge[1];
        } else {
          return this.constrained_edge[2];
        }
      };

      Triangle.prototype.setConstrainedEdgeCW = function (p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          this.constrained_edge[1] = ce;
        } else if (p === this.points_[1]) {
          this.constrained_edge[2] = ce;
        } else {
          this.constrained_edge[0] = ce;
        }
      };

      Triangle.prototype.setConstrainedEdgeCCW = function (p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          this.constrained_edge[2] = ce;
        } else if (p === this.points_[1]) {
          this.constrained_edge[0] = ce;
        } else {
          this.constrained_edge[1] = ce;
        }
      };

      Triangle.prototype.getDelaunayEdgeCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.delaunay_edge[1];
        } else if (p === this.points_[1]) {
          return this.delaunay_edge[2];
        } else {
          return this.delaunay_edge[0];
        }
      };

      Triangle.prototype.getDelaunayEdgeCCW = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.delaunay_edge[2];
        } else if (p === this.points_[1]) {
          return this.delaunay_edge[0];
        } else {
          return this.delaunay_edge[1];
        }
      };

      Triangle.prototype.setDelaunayEdgeCW = function (p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          this.delaunay_edge[1] = e;
        } else if (p === this.points_[1]) {
          this.delaunay_edge[2] = e;
        } else {
          this.delaunay_edge[0] = e;
        }
      };

      Triangle.prototype.setDelaunayEdgeCCW = function (p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          this.delaunay_edge[2] = e;
        } else if (p === this.points_[1]) {
          this.delaunay_edge[0] = e;
        } else {
          this.delaunay_edge[1] = e;
        }
      };

      /**
          * The neighbor across to given point.
          * @private
          * @param {XY} p - point object with {x,y}
          * @returns {Triangle}
          */
      Triangle.prototype.neighborAcross = function (p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
          return this.neighbors_[0];
        } else if (p === this.points_[1]) {
          return this.neighbors_[1];
        } else {
          return this.neighbors_[2];
        }
      };

      /**
          * @private
          * @param {!Triangle} t Triangle object.
          * @param {XY} p - point object with {x,y}
          */
      Triangle.prototype.oppositePoint = function (t, p) {
        var cw = t.pointCW(p);
        return this.pointCW(cw);
      };

      /**
          * Legalize triangle by rotating clockwise around oPoint
          * @private
          * @param {XY} opoint - point object with {x,y}
          * @param {XY} npoint - point object with {x,y}
          * @throws {Error} if oPoint can not be found
          */
      Triangle.prototype.legalize = function (opoint, npoint) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (opoint === points[0]) {
          points[1] = points[0];
          points[0] = points[2];
          points[2] = npoint;
        } else if (opoint === points[1]) {
          points[2] = points[1];
          points[1] = points[0];
          points[0] = npoint;
        } else if (opoint === points[2]) {
          points[0] = points[2];
          points[2] = points[1];
          points[1] = npoint;
        } else {
          throw new Error('poly2tri Invalid Triangle.legalize() call');
        }
      };

      /**
          * Returns the index of a point in the triangle. 
          * The point *must* be a reference to one of the triangle's vertices.
          * @private
          * @param {XY} p - point object with {x,y}
          * @returns {number} index 0, 1 or 2
          * @throws {Error} if p can not be found
          */
      Triangle.prototype.index = function (p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
          return 0;
        } else if (p === points[1]) {
          return 1;
        } else if (p === points[2]) {
          return 2;
        } else {
          throw new Error('poly2tri Invalid Triangle.index() call');
        }
      };

      /**
          * @private
          * @param {XY} p1 - point object with {x,y}
          * @param {XY} p2 - point object with {x,y}
          * @return {number} index 0, 1 or 2, or -1 if errror
          */
      Triangle.prototype.edgeIndex = function (p1, p2) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p1 === points[0]) {
          if (p2 === points[1]) {
            return 2;
          } else if (p2 === points[2]) {
            return 1;
          }
        } else if (p1 === points[1]) {
          if (p2 === points[2]) {
            return 0;
          } else if (p2 === points[0]) {
            return 2;
          }
        } else if (p1 === points[2]) {
          if (p2 === points[0]) {
            return 1;
          } else if (p2 === points[1]) {
            return 0;
          }
        }
        return -1;
      };

      /**
          * Mark an edge of this triangle as constrained.
          * @private
          * @param {number} index - edge index
          */
      Triangle.prototype.markConstrainedEdgeByIndex = function (index) {
        this.constrained_edge[index] = true;
      };
      /**
          * Mark an edge of this triangle as constrained.
          * @private
          * @param {Edge} edge instance
          */
      Triangle.prototype.markConstrainedEdgeByEdge = function (edge) {
        this.markConstrainedEdgeByPoints(edge.p, edge.q);
      };
      /**
          * Mark an edge of this triangle as constrained.
          * This method takes two Point instances defining the edge of the triangle.
          * @private
          * @param {XY} p - point object with {x,y}
          * @param {XY} q - point object with {x,y}
          */
      Triangle.prototype.markConstrainedEdgeByPoints = function (p, q) {
        var points = this.points_;
        // Here we are comparing point references, not values        
        if (q === points[0] && p === points[1] || q === points[1] && p === points[0]) {
          this.constrained_edge[2] = true;
        } else if (q === points[0] && p === points[2] || q === points[2] && p === points[0]) {
          this.constrained_edge[1] = true;
        } else if (q === points[1] && p === points[2] || q === points[2] && p === points[1]) {
          this.constrained_edge[0] = true;
        }
      };


      // ---------------------------------------------------------Exports (public API)

      module.exports = Triangle;

    }, { "./xy": 11 }], 10: [function (require, module, exports) {
      /*
                                                                   * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                                   * http://code.google.com/p/poly2tri/
                                                                   * 
                                                                   * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                                   * https://github.com/r3mi/poly2tri.js
                                                                   * 
                                                                   * All rights reserved.
                                                                   * 
                                                                   * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                                   */

      "use strict";

      /**
                     * Precision to detect repeated or collinear points
                     * @private
                     * @const {number}
                     * @default
                     */
      var EPSILON = 1e-12;
      exports.EPSILON = EPSILON;

      /**
                                  * @private
                                  * @enum {number}
                                  * @readonly
                                  */
      var Orientation = {
        "CW": 1,
        "CCW": -1,
        "COLLINEAR": 0 };

      exports.Orientation = Orientation;


      /**
                                          * Formula to calculate signed area<br>
                                          * Positive if CCW<br>
                                          * Negative if CW<br>
                                          * 0 if collinear<br>
                                          * <pre>
                                          * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                                          *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
                                          * </pre>
                                          *
                                          * @private
                                          * @param {!XY} pa  point object with {x,y}
                                          * @param {!XY} pb  point object with {x,y}
                                          * @param {!XY} pc  point object with {x,y}
                                          * @return {Orientation}
                                          */
      function orient2d(pa, pb, pc) {
        var detleft = (pa.x - pc.x) * (pb.y - pc.y);
        var detright = (pa.y - pc.y) * (pb.x - pc.x);
        var val = detleft - detright;
        if (val > -EPSILON && val < EPSILON) {
          return Orientation.COLLINEAR;
        } else if (val > 0) {
          return Orientation.CCW;
        } else {
          return Orientation.CW;
        }
      }
      exports.orient2d = orient2d;


      /**
                                    *
                                    * @private
                                    * @param {!XY} pa  point object with {x,y}
                                    * @param {!XY} pb  point object with {x,y}
                                    * @param {!XY} pc  point object with {x,y}
                                    * @param {!XY} pd  point object with {x,y}
                                    * @return {boolean}
                                    */
      function inScanArea(pa, pb, pc, pd) {
        var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
        if (oadb >= -EPSILON) {
          return false;
        }

        var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
        if (oadc <= EPSILON) {
          return false;
        }
        return true;
      }
      exports.inScanArea = inScanArea;


      /**
                                        * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
                                        *
                                        * @private
                                        * @param {!XY} pa  point object with {x,y}
                                        * @param {!XY} pb  point object with {x,y}
                                        * @param {!XY} pc  point object with {x,y}
                                        * @return {boolean} true if angle is obtuse
                                        */
      function isAngleObtuse(pa, pb, pc) {
        var ax = pb.x - pa.x;
        var ay = pb.y - pa.y;
        var bx = pc.x - pa.x;
        var by = pc.y - pa.y;
        return ax * bx + ay * by < 0;
      }
      exports.isAngleObtuse = isAngleObtuse;


    }, {}], 11: [function (require, module, exports) {
      /*
                                                       * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
                                                       * http://code.google.com/p/poly2tri/
                                                       * 
                                                       * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
                                                       * https://github.com/r3mi/poly2tri.js
                                                       * 
                                                       * All rights reserved.
                                                       * 
                                                       * Distributed under the 3-clause BSD License, see LICENSE.txt
                                                       */

      "use strict";

      /**
                     * The following functions operate on "Point" or any "Point like" object with {x,y},
                     * as defined by the {@link XY} type
                     * ({@link http://en.wikipedia.org/wiki/Duck_typing|duck typing}).
                     * @module
                     * @private
                     */

      /**
                         * poly2tri.js supports using custom point class instead of {@linkcode Point}.
                         * Any "Point like" object with <code>{x, y}</code> attributes is supported
                         * to initialize the SweepContext polylines and points
                         * ({@link http://en.wikipedia.org/wiki/Duck_typing|duck typing}).
                         *
                         * poly2tri.js might add extra fields to the point objects when computing the
                         * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
                         * with fields in the custom class.
                         *
                         * @example
                         *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
                         *      var swctx = new poly2tri.SweepContext(contour);
                         *
                         * @typedef {Object} XY
                         * @property {number} x - x coordinate
                         * @property {number} y - y coordinate
                         */


      /**
                             * Point pretty printing : prints x and y coordinates.
                             * @example
                             *      xy.toStringBase({x:5, y:42})
                             *      // → "(5;42)"
                             * @protected
                             * @param {!XY} p - point object with {x,y}
                             * @returns {string} <code>"(x;y)"</code>
                             */
      function toStringBase(p) {
        return "(" + p.x + ";" + p.y + ")";
      }

      /**
         * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
         * else simply prints x and y coordinates.
         * @example
         *      xy.toString({x:5, y:42})
         *      // → "(5;42)"
         * @example
         *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
         *      // → "5:42"
         * @param {!XY} p - point object with {x,y}
         * @returns {string} <code>"(x;y)"</code>
         */
      function toString(p) {
        // Try a custom toString first, and fallback to own implementation if none
        var s = p.toString();
        return s === '[object Object]' ? toStringBase(p) : s;
      }


      /**
         * Compare two points component-wise. Ordered by y axis first, then x axis.
         * @param {!XY} a - point object with {x,y}
         * @param {!XY} b - point object with {x,y}
         * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
         *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
         *         <code>0</code> otherwise.
         */
      function compare(a, b) {
        if (a.y === b.y) {
          return a.x - b.x;
        } else {
          return a.y - b.y;
        }
      }

      /**
         * Test two Point objects for equality.
         * @param {!XY} a - point object with {x,y}
         * @param {!XY} b - point object with {x,y}
         * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
         */
      function equals(a, b) {
        return a.x === b.x && a.y === b.y;
      }


      module.exports = {
        toString: toString,
        toStringBase: toStringBase,
        compare: compare,
        equals: equals };


    }, {}] }, {}, [6])(6);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./extensions/CompGeom/quad-tree.js":
/*!******************************************!*\
  !*** ./extensions/CompGeom/quad-tree.js ***!
  \******************************************/
/*! exports provided: QuadTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadTree", function() { return QuadTree; });
/* harmony import */ var _x_line_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x-line-box */ "./extensions/CompGeom/x-line-box.js");
/* harmony import */ var _x_box_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x-box-box */ "./extensions/CompGeom/x-box-box.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


//Spatial index data structure for fast lookup of line segments

var ITEMS_PER_NODE = 16;
var EPS = 1e-20;
var avp = Autodesk.Viewing.Private;
var logger = avp.logger;

var QuadTree = /*#__PURE__*/function () {

  function QuadTree(minx, miny, maxx, maxy, extraDistance) {_classCallCheck(this, QuadTree);

    this.items = [];
    this.children = null;
    this.itemCount = 0;

    this.extraDistance = extraDistance;

    this.minx = minx;
    this.miny = miny;
    this.maxx = maxx;
    this.maxy = maxy;
  }_createClass(QuadTree, [{ key: "addItem", value: function addItem(


    e) {

      //TODO: must check if item fits inside our total bbox
      //before adding. In such case we may have to expand the
      //tree somehow

      this.itemCount++;

      if (this.children) {
        var overlapCount = 0;
        var whichChild = null;

        for (var i = 0; i < 4; i++) {
          if (this.children[i].intersectsItem(e)) {
            whichChild = this.children[i];
            overlapCount++;
          }
        }

        if (overlapCount === 0) {

        } else if (overlapCount === 1) {
          whichChild.addItem(e);
        } else {
          this.items.push(e);
        }

      } else {
        this.items.push(e);

        if (this.items.length > ITEMS_PER_NODE)
        this.subdivide();
      }

      return this.itemCount;
    } }, { key: "deleteItem", value: function deleteItem(

    e) {

      if (!this.intersectsItem(e))
      return 0;

      if (this.items) {
        var idx = this.items.indexOf(e);
        if (idx >= 0) {
          this.items.splice(idx, 1);
          this.itemCount--;
          return 1;
        }
      }

      if (this.children) {
        var deleteCount = 0;
        var remainingItemsCount = 0;
        for (var i = 0; i < 4; i++) {
          deleteCount += this.children[i].deleteItem(e);
          remainingItemsCount += this.children[i].itemCount;
        }

        if (remainingItemsCount < ITEMS_PER_NODE) {
          //TODO: un-split the node here
        }

        if (deleteCount === 1) {
          this.itemCount--;
          return 1;
        } else {
          logger.warn("Did not find item to delete. Something is wrong.", deleteCount);
          return 0;
        }
      }

      return 0;
    } }, { key: "intersectsBox", value: function intersectsBox(

    minx, miny, maxx, maxy) {

      var d = this.extraDistance;

      return Object(_x_box_box__WEBPACK_IMPORTED_MODULE_1__["xBoxBox"])(minx, miny, maxx, maxy,
      this.minx - d, this.miny - d, this.maxx + d, this.maxy + d);
    } }, { key: "intersectsItem", value: function intersectsItem(

    e) {
      //Meh... polymorphism seems like overkill if all we want to support here is
      //edges and vertices...
      if (e.v1) {
        //Edge
        return Object(_x_line_box__WEBPACK_IMPORTED_MODULE_0__["xLineBox"])(e.v1.x, e.v1.y, e.v2.x, e.v2.y,
        this.minx - this.extraDistance, this.miny - this.extraDistance,
        this.maxx + this.extraDistance, this.maxy + this.extraDistance);
      } else {
        //Vertex
        return this.intersectsBox(e.x, e.y, e.x, e.y);
      }
    } }, { key: "findSplitPoint", value: function findSplitPoint()

    {
      //determine split location -- we split along the
      //midpoint of actual data inside the node
      var xs = [];
      var ys = [];

      //Meh... polymorphism seems like overkill if all we want to support here is
      //edges and vertices...
      if (this.items[0].v1) {
        for (var i = 0; i < this.items.length; i++) {
          xs.push(this.items[i].v1.x);
          ys.push(this.items[i].v1.y);
        }
      } else {
        for (var _i = 0; _i < this.items.length; _i++) {
          xs.push(this.items[_i].x);
          ys.push(this.items[_i].y);
        }
      }

      xs.sort(function (a, b) {return a - b;});
      ys.sort(function (a, b) {return a - b;});

      //Split slightly to the left of the median min point for all edge items
      var midx = xs[0 | (xs.length + 1) / 2] - this.extraDistance - EPS;
      var midy = ys[0 | (ys.length + 1) / 2] - this.extraDistance - EPS;

      if (midx <= this.minx || midx >= this.maxx || midy <= this.miny || midy >= this.maxy) {
        logger.warn("Failed to split quad tree node. Something is wrong with the split choice.");
        return null;
      }

      return { midx: midx, midy: midy };
    } }, { key: "subdivide", value: function subdivide()


    {

      if (this.children) {
        logger.error("Attempt to subdivide already split node");
        return;
      }

      if (!this.items.length) {
        logger.error("Attempt to subdivide empty node");
        return;
      }

      var minx = this.minx;
      var miny = this.miny;
      var maxx = this.maxx;
      var maxy = this.maxy;

      //determine split location -- we split along the
      //midpoint of actual data inside the node
      var split = this.findSplitPoint();

      if (!split) {
        logger.warn("Failed to split node");
        return;
      }var

      midx = split.midx,midy = split.midy;

      this.children = new Array(4);
      this.children[0] = new QuadTree(minx, miny, midx, midy, this.extraDistance);
      this.children[1] = new QuadTree(midx, miny, maxx, midy, this.extraDistance);
      this.children[2] = new QuadTree(midx, midy, maxx, maxy, this.extraDistance);
      this.children[3] = new QuadTree(minx, midy, midx, maxy, this.extraDistance);

      var keepItems = [];

      for (var i = 0, iEnd = this.items.length; i < iEnd; i++) {

        var overlapCount = 0;
        var whichChild = null;

        for (var j = 0; j < 4; j++) {
          if (this.children[j].intersectsItem(this.items[i])) {
            whichChild = this.children[j];
            overlapCount++;
          }
        }

        if (overlapCount === 0) {
          logger.error("Expected at least one overlap");
        } else if (overlapCount === 1) {
          whichChild.addItem(this.items[i]);
        } else {
          keepItems.push(this.items[i]);
        }
      }

      this.items = keepItems;
    } }, { key: "enumNearItems", value: function enumNearItems(

    e, cb) {

      if (!this.intersectsItem(e))
      return;

      if (this.items) {
        for (var i = 0; i < this.items.length; i++) {
          cb(this.items[i]);
        }
      }

      if (this.children) {
        for (var _i2 = 0; _i2 < 4; _i2++) {
          this.children[_i2].enumNearItems(e, cb);
        }
      }

    } }, { key: "enumInBox", value: function enumInBox(

    minx, miny, maxx, maxy, cb) {

      if (!this.intersectsBox(minx, miny, maxx, maxy))
      return;

      if (this.items) {
        for (var i = 0; i < this.items.length; i++) {
          var e = this.items[i];

          if (e.v1) {
            if (Object(_x_line_box__WEBPACK_IMPORTED_MODULE_0__["xLineBox"])(e.v1.x, e.v1.y, e.v2.x, e.v2.y, minx, miny, maxx, maxy))
            cb(e);
          } else {
            if (Object(_x_box_box__WEBPACK_IMPORTED_MODULE_1__["xBoxBox"])(e.x, e.y, e.x, e.y, minx, miny, maxx, maxy))
            cb(e);
          }
        }
      }

      if (this.children) {
        for (var _i3 = 0; _i3 < 4; _i3++) {
          this.children[_i3].enumInBox(minx, miny, maxx, maxy, cb);
        }
      }

    } }, { key: "pointInPolygonRec", value: function pointInPolygonRec(


    e, x, y) {

      // get the last point in the polygon
      var vtx0X = e.v1.x;
      var vtx0Y = e.v1.y;

      // get test bit for above/below X axis
      var yflag0 = vtx0Y >= y;

      var vtx1X = e.v2.x;
      var vtx1Y = e.v2.y;

      var yflag1 = vtx1Y >= y;

      // Check if endpoints straddle (are on opposite sides) of X axis
      // (i.e. the Y's differ); if so, +X ray could intersect this edge.
      // The old test also checked whether the endpoints are both to the
      // right or to the left of the test point.  However, given the faster
      // intersection point computation used below, this test was found to
      // be a break-even proposition for most polygons and a loser for
      // triangles (where 50% or more of the edges which survive this test
      // will cross quadrants and so have to have the X intersection computed
      // anyway).  I credit Joseph Samosky with inspiring me to try dropping
      // the "both left or both right" part of my code.
      if (yflag0 != yflag1)
      {
        // Check intersection of pgon segment with +X ray.
        // Note if >= point's X; if so, the ray hits it.
        // The division operation is avoided for the ">=" test by checking
        // the sign of the first vertex wrto the test point; idea inspired
        // by Joseph Samosky's and Mark Haigh-Hutchinson's different
        // polygon inclusion tests.
        if ((vtx1Y - y) * (vtx0X - vtx1X) >=
        (vtx1X - x) * (vtx0Y - vtx1Y) == yflag1)
        {
          this.pipResult = !this.pipResult;
        }
      }

    } }, { key: "pointInPolygon", value: function pointInPolygon(

    x, y) {var _this = this;

      this.pipResult = false;

      this.enumInBox(-Infinity, y, Infinity, y, function (item) {

        _this.pointInPolygonRec(item, x, y);

      });

      return this.pipResult;

    } }]);return QuadTree;}();

/***/ }),

/***/ "./extensions/CompGeom/x-box-box.js":
/*!******************************************!*\
  !*** ./extensions/CompGeom/x-box-box.js ***!
  \******************************************/
/*! exports provided: xBoxBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xBoxBox", function() { return xBoxBox; });

function xBoxBox(minx1, miny1, maxx1, maxy1,
minx2, miny2, maxx2, maxy2) {

  return minx1 <= maxx2 &&
  miny1 <= maxy2 &&
  maxx1 >= minx2 &&
  maxy1 >= miny2;

}

/***/ }),

/***/ "./extensions/CompGeom/x-box-plane.js":
/*!********************************************!*\
  !*** ./extensions/CompGeom/x-box-plane.js ***!
  \********************************************/
/*! exports provided: xBoxPlane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xBoxPlane", function() { return xBoxPlane; });

var point = new THREE.Vector3();

function xBoxPlane(plane, box) {

  point.set(box.min.x, box.min.y, box.min.z); // 000
  var d = plane.distanceToPoint(point);
  var s = Math.sign(d);

  point.set(box.min.x, box.min.y, box.max.z); // 001
  var d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.min.x, box.max.y, box.min.z); // 010
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.min.x, box.max.y, box.max.z); // 011
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.max.x, box.min.y, box.min.z); // 100
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.max.x, box.min.y, box.max.z); // 101
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.max.x, box.max.y, box.min.z); // 110
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  point.set(box.max.x, box.max.y, box.max.z); // 111
  d2 = plane.distanceToPoint(point);
  if (Math.sign(d2) !== s)
  return true;

  return false;
}

/***/ }),

/***/ "./extensions/CompGeom/x-line-box.js":
/*!*******************************************!*\
  !*** ./extensions/CompGeom/x-line-box.js ***!
  \*******************************************/
/*! exports provided: xLineBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xLineBox", function() { return xLineBox; });

var INSIDE = 0; // 0000
var LEFT = 1; // 0001
var RIGHT = 2; // 0010
var BOTTOM = 4; // 0100
var TOP = 8; // 1000

// Compute the bit code for a point (x, y) using the clip rectangle
// bounded diagonally by (xmin, ymin), and (xmax, ymax)

function ComputeOutCode(x, y, xmin, ymin, xmax, ymax)
{
  var code;

  code = INSIDE; // initialised as being inside of [[clip window]]

  if (x < xmin) // to the left of clip window
    code |= LEFT;else
  if (x > xmax) // to the right of clip window
    code |= RIGHT;
  if (y < ymin) // below the clip window
    code |= BOTTOM;else
  if (y > ymax) // above the clip window
    code |= TOP;

  return code;
}

// Cohen–Sutherland clipping algorithm clips a line from
// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with
// diagonal from (xmin, ymin) to (xmax, ymax).
function xLineBox(x0, y0, x1, y1, xmin, ymin, xmax, ymax)
{
  // compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
  var outcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);
  var outcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);
  var accept = false;

  while (true) {
    if (!(outcode0 | outcode1)) {
      // bitwise OR is 0: both points inside window; trivially accept and exit loop
      accept = true;
      break;
    } else if (outcode0 & outcode1) {
      // bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,
      // or BOTTOM), so both must be outside window; exit loop (accept is false)
      break;
    } else {
      // failed both tests, so calculate the line segment to clip
      // from an outside point to an intersection with clip edge
      var x = void 0,y = void 0;

      // At least one endpoint is outside the clip rectangle; pick it.
      var outcodeOut = outcode0 ? outcode0 : outcode1;

      // Now find the intersection point;
      // use formulas:
      //   slope = (y1 - y0) / (x1 - x0)
      //   x = x0 + (1 / slope) * (ym - y0), where ym is ymin or ymax
      //   y = y0 + slope * (xm - x0), where xm is xmin or xmax
      // No need to worry about divide-by-zero because, in each case, the
      // outcode bit being tested guarantees the denominator is non-zero
      if (outcodeOut & TOP) {// point is above the clip window
        x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);
        y = ymax;
      } else if (outcodeOut & BOTTOM) {// point is below the clip window
        x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);
        y = ymin;
      } else if (outcodeOut & RIGHT) {// point is to the right of clip window
        y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);
        x = xmax;
      } else if (outcodeOut & LEFT) {// point is to the left of clip window
        y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);
        x = xmin;
      }

      // Now we move outside point to intersection point to clip
      // and get ready for next pass.
      if (outcodeOut === outcode0) {
        x0 = x;
        y0 = y;
        outcode0 = ComputeOutCode(x0, y0, xmin, ymin, xmax, ymax);
      } else {
        x1 = x;
        y1 = y;
        outcode1 = ComputeOutCode(x1, y1, xmin, ymin, xmax, ymax);
      }
    }
  }

  return accept;
}

/***/ }),

/***/ "./extensions/CompGeom/x-line-line.js":
/*!********************************************!*\
  !*** ./extensions/CompGeom/x-line-line.js ***!
  \********************************************/
/*! exports provided: ONE_INTERSECTION, OVERLAP, pointOnLine, segmentsIntersect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_INTERSECTION", function() { return ONE_INTERSECTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OVERLAP", function() { return OVERLAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointOnLine", function() { return pointOnLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentsIntersect", function() { return segmentsIntersect; });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");



function ABS(x) {
  return Math.abs(x);
}

var EPS = _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"];

var ONE_INTERSECTION = 4;
var OVERLAP = 5;


//Returns true if the given point lies on and inside the given line segment
function pointOnLine(x, y, e, checkInsideSegment, precisionDistance, outPt) {

  if (e.length < EPS) {
    return false;
  }

  var dot = (x - e.v1.x) * e.dx + (y - e.v1.y) * e.dy;

  if (!precisionDistance)
  precisionDistance = EPS * e.length;

  var u = dot / e.length2;

  if (checkInsideSegment) {
    if (u * e.length < -precisionDistance || u * e.length > e.length + precisionDistance)
    return false;
  }

  var lx = e.v1.x + u * e.dx;
  var ly = e.v1.y + u * e.dy;

  var len2 = (lx - x) * (lx - x) + (ly - y) * (ly - y);

  if (outPt) {
    outPt.x = lx;
    outPt.y = ly;
    outPt.d = Math.sqrt(len2);
    outPt.u = u;
  }

  if (len2 < precisionDistance * precisionDistance)
  return true;

  return false;
}


function parallelLinesOverlap(e1, e2, precisionDistance) {

  //Check of the segments are parallel but not on the same infinite line
  if (!pointOnLine(e2.v1.x, e2.v1.y, e1, false, precisionDistance)) {
    return null;
  }

  var res = {
    status: OVERLAP,
    e1: [],
    e2: [] };


  //They are on the same line. Find overlap points.
  //TODO: There is probably a more efficient way to do this
  var p3_seg1 = pointOnLine(e2.v1.x, e2.v1.y, e1, true, precisionDistance);
  var p4_seg1 = pointOnLine(e2.v2.x, e2.v2.y, e1, true, precisionDistance);

  //If both points of the second segment are inside the first
  //then the reverse cannot be true...
  if (p3_seg1 && p4_seg1) {
    res.e1.push(e2.v1.x, e2.v1.y, e2.v2.x, e2.v2.y);
    return res;
  }

  var p1_seg2 = pointOnLine(e1.v1.x, e1.v1.y, e2, true, precisionDistance);
  var p2_seg2 = pointOnLine(e1.v2.x, e1.v2.y, e2, true, precisionDistance);

  if (p3_seg1)
  res.e1.push(e2.v1.x, e2.v1.y);
  if (p4_seg1)
  res.e1.push(e2.v2.x, e2.v2.y);
  if (p1_seg2)
  res.e2.push(e1.v1.x, e1.v1.y);
  if (p2_seg2)
  res.e2.push(e1.v2.x, e1.v2.y);

  return res;
}


/*
     Determine the intersection point of two line segments
     Modified source from here:
     http://www.paulbourke.net/geometry/pointlineplane/
  */
function segmentsIntersect(e1, e2, precisionDistance)
{
  var denom = e2.dy * e1.dx - e2.dx * e1.dy;
  var numera = e2.dx * (e1.v1.y - e2.v1.y) - e2.dy * (e1.v1.x - e2.v1.x);
  var numerb = e1.dx * (e1.v1.y - e2.v1.y) - e1.dy * (e1.v1.x - e2.v1.x);

  /* Are the lines coincident? */
  if (ABS(numera) < EPS && ABS(numerb) < EPS && ABS(denom) < EPS) {
    return null;
  }

  /* Are the lines parallel */
  if (ABS(denom) < EPS) {
    /* check for overlap */
    return parallelLinesOverlap(e1, e2, precisionDistance);
  }

  /* Is the intersection along the segments */
  var mua = numera / denom;
  var da = mua * e1.length;
  if (da < -precisionDistance || da > e1.length + precisionDistance) {
    return null;
  }

  var mub = numerb / denom;
  var db = mub * e2.length;
  if (db < -precisionDistance || db > e2.length + precisionDistance) {
    return null;
  }

  var x = e1.v1.x + mua * e1.dx;
  var y = e1.v1.y + mua * e1.dy;

  return {
    status: ONE_INTERSECTION,
    e1: [x, y],
    e2: [x, y] };

}

/***/ }),

/***/ "./extensions/CompGeom/x-mesh-plane.js":
/*!*********************************************!*\
  !*** ./extensions/CompGeom/x-mesh-plane.js ***!
  \*********************************************/
/*! exports provided: xMeshPlane, makePlaneBasis, convertToPlaneCoords */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xMeshPlane", function() { return xMeshPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePlaneBasis", function() { return makePlaneBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToPlaneCoords", function() { return convertToPlaneCoords; });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");
/* harmony import */ var _x_triangle_plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x-triangle-plane */ "./extensions/CompGeom/x-triangle-plane.js");



//const THREE = THREE;
var avp = Autodesk.Viewing.Private;
var VertexEnumerator = avp.VertexEnumerator;





var mi = new THREE.Matrix4();
var pi = new THREE.Plane();

function xMeshPlane(plane, mesh, intersects) {

  var geometry = mesh.geometry;

  if (!geometry)
  return;

  var baseIndex = intersects.length;

  var matrixWorld = mesh.matrixWorld;
  mi.getInverse(matrixWorld);
  pi.copy(plane).applyMatrix4(mi);

  VertexEnumerator.enumMeshTriangles(geometry, function (vA, vB, vC, a, b, c) {

    Object(_x_triangle_plane__WEBPACK_IMPORTED_MODULE_1__["xTrianglePlane"])(pi, vA, vB, vC, a, b, c, intersects, mesh.fragId);

  });

  //Put the points into world space. It should actually be possible to do
  //the entire math in object space -- but we have to check if all fragments
  //that belong to the same dbId have the same world transform.
  for (var i = baseIndex, iEnd = intersects.length; i < iEnd; i++) {
    intersects[i].v1.applyMatrix4(matrixWorld);
    intersects[i].v2.applyMatrix4(matrixWorld);
  }

}


function makeRotationAxis(axis, cosa, m) {

  // Based on http://www.gamedev.net/reference/articles/article1199.asp

  var c = cosa;
  var s = Math.sqrt(1.0 - c * c);
  var t = 1 - c;
  var x = axis.x,y = axis.y,z = axis.z;
  var tx = t * x,ty = t * y;

  m.set(

  tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  0, 0, 0, 1);



}


function makePlaneBasis(plane) {

  //var origin = plane.coplanarPoint();

  var sceneUp = new THREE.Vector3(0, 0, 1);
  var cross = plane.normal.clone().cross(sceneUp);
  cross = cross.normalize();
  var dot = sceneUp.dot(plane.normal);

  //We are ignoring the translation here, since
  //we will drop the Z coord for the 2D processing steps anyway.
  var planeBasis = new THREE.Matrix4();

  if (!(Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["isZero"])(cross.x) && Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["isZero"])(cross.y) && Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["isZero"])(cross.z))) {
    makeRotationAxis(cross, dot, planeBasis);
    planeBasis.elements[14] = plane.constant;
  } else {
    planeBasis.elements[14] = dot * plane.constant;
  }

  return planeBasis;
}


function convertToPlaneCoords(planeBasis, edges3d, bbox) {

  for (var i = 0; i < edges3d.length; i++) {
    var e = edges3d[i];

    e.v1.applyMatrix4(planeBasis);
    e.v2.applyMatrix4(planeBasis);

    bbox.expandByPoint(e.v1);
    bbox.expandByPoint(e.v2);
  }
}

/***/ }),

/***/ "./extensions/CompGeom/x-plane-segment.js":
/*!************************************************!*\
  !*** ./extensions/CompGeom/x-plane-segment.js ***!
  \************************************************/
/*! exports provided: xPlaneSegment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xPlaneSegment", function() { return xPlaneSegment; });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");



var v1 = new THREE.Vector3();

function xPlaneSegment(plane, pt0, pt1, res1, res2) {

  var direction = v1.subVectors(pt1, pt0);

  var denominator = plane.normal.dot(direction);

  if (Object(_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["isZero"])(denominator)) {

    res1.copy(pt0);
    res2.copy(pt1);

    // line is coplanar
    return 2;
  }

  denominator = 1.0 / denominator;

  var t = -(pt0.dot(plane.normal) * denominator + plane.constant * denominator);

  if (t < -_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] || t > 1 + _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"]) {

    return 0;

  }

  var pt = direction.multiplyScalar(t).add(pt0);

  res1.copy(pt);

  return 1;
}

/***/ }),

/***/ "./extensions/CompGeom/x-triangle-plane.js":
/*!*************************************************!*\
  !*** ./extensions/CompGeom/x-triangle-plane.js ***!
  \*************************************************/
/*! exports provided: xTrianglePlane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xTrianglePlane", function() { return xTrianglePlane; });
/* harmony import */ var _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fuzzy-math */ "./extensions/CompGeom/fuzzy-math.js");
/* harmony import */ var _x_plane_segment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x-plane-segment */ "./extensions/CompGeom/x-plane-segment.js");



var avp = Autodesk.Viewing.Private;
var logger = avp.logger;

function Edge(pt1, pt2, id1From, id1To, id2From, id2To, meshId) {

  this.v1 = pt1.clone();
  this.v2 = pt2.clone();

}



var res1 = new THREE.Vector3();
var res2 = new THREE.Vector3();

// res is array containing result segments.
// returns number of intersection point on the plane (0, 1, or 2) with the values of the points stored in the res array
function xTrianglePlane(plane, pt0, pt1, pt2, i0, i1, i2, res, meshId) {

  var d0 = plane.distanceToPoint(pt0);
  var d1 = plane.distanceToPoint(pt1);
  var d2 = plane.distanceToPoint(pt2);

  // Check if all points are to one side of the plane
  if (d0 < -_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] && d1 < -_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] && d2 < -_fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"]) {
    return null;
  }
  if (d0 > _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] && d1 > _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"] && d2 > _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"]) {
    return null;
  }

  var s0 = Math.sign(d0);
  var s1 = Math.sign(d1);
  var s2 = Math.sign(d2);

  // Skip coplanar triangles (leave it to the neighbouring triangles to contribute their edges)
  if (s0 === 0 && s1 === 0 && s2 === 0) {
    return null;
  }

  var tmp1, tmp2;
  var i1From, i1To, i2From, i2To;

  //There is intersection, compute it
  if (s0 !== s1) {
    var numInts = Object(_x_plane_segment__WEBPACK_IMPORTED_MODULE_1__["xPlaneSegment"])(plane, pt0, pt1, res1, res2);
    if (numInts === 2) {
      res.push(new Edge(pt0, pt1, i0, i0, i1, i1, meshId));
      return;
    } else if (numInts === 1) {
      i1From = i0;
      i1To = i1;
      tmp1 = res1.clone();
    } else {
      logger.warn("Unexpected zero intersections where at least one was expected");
    }
  }

  if (s1 !== s2) {
    var _numInts = Object(_x_plane_segment__WEBPACK_IMPORTED_MODULE_1__["xPlaneSegment"])(plane, pt1, pt2, res1, res2);
    if (_numInts === 2) {
      res.push(new Edge(pt1, pt2, i1, i1, i2, i2, meshId));
      return;
    } else if (_numInts === 1) {
      if (tmp1) {
        // Avoid the singular scenario where the signs are 0, -1 and +1
        if (res1.distanceTo(tmp1) > _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"]) {
          i2From = i1;
          i2To = i2;
          tmp2 = res1.clone();
        }
      } else
      {
        i1From = i1;
        i1To = i2;
        tmp1 = res1.clone();
      }
    } else {
      logger.warn("Unexpected zero intersections where at least one was expected");
    }
  }

  if (s2 !== s0) {
    var _numInts2 = Object(_x_plane_segment__WEBPACK_IMPORTED_MODULE_1__["xPlaneSegment"])(plane, pt2, pt0, res1, res2);
    if (_numInts2 === 2) {
      res.push(new Edge(pt2, pt0, i2, i2, i0, i0, meshId));
      return;
    } else if (_numInts2 === 1) {
      if (tmp1) {
        // Avoid the singular scenario where the signs are 0, -1 and +1
        if (res1.distanceTo(tmp1) > _fuzzy_math__WEBPACK_IMPORTED_MODULE_0__["TOL"]) {
          i2From = i2;
          i2To = i0;
          tmp2 = res1.clone();
        }
      } else {
        logger.warn("Unexpected single intersection point");
      }
    } else {
      logger.warn("Unexpected zero intersections where at least one was expected");
    }
  }


  if (tmp1 && tmp2) {
    res.push(new Edge(tmp1, tmp2, i1From, i1To, i2From, i2To, meshId));
  } else {
    //logger.warn("Unexpected one intersection where two were expected");
  }

}

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
//# sourceMappingURL=CompGeom.js.map